---
title: 理解Reactor与Proactor
categories: java
date: 2018-03-06 20:49:42
tags: java
---

## BIO与NI0

BIO是Java IO最开始提供的一种IO模型，在传统BIO中，ServerSocket 负责绑定IP地址，启动监听端口；Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通信。采用BIO通信模型的Server，通常由一个独立的Acceptor线程负责监听Client端的连接，它接受到Client端连接请求后为每个Client创建一个新的线程进行处理，处理完之后，通过输出流返回给Client端，线程销毁。

在高并发场景下，BIO模型的弊端就显露无疑，流量增大会导致线程数膨胀最终导致服务崩溃。其实BIO对此有所改进，抛弃线程一对一处理请求，使用线程池处理所有客户端请求，另外使用消息队列接受客户端请求。但由于它仍然是面向数据流的，底层仍然是同步阻塞模型，阻塞时间取决于线程处理时间和IO传输时间。

NIO相对BIO来说是一种新的IO模型，与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel和 ServerSocketChannel两种不同套接字通道的实现，它们都支持阻塞和非阻塞两种模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞IO以降低复杂度，但是高负载、高并发的网络应用，需要使用NIO的非阻塞模式进行开发。NIO这里不做详细介绍。

## Reactor与Proactor

reactor和proactor是两种常用的事件分发IO多路复用方案。通常来讲 reactor是基于同步IO，而proactor是基于异步IO（不是绝对的），两者都是有一个event demultiplexer（事件多路分解器）来检测IO状态，不同的handler来注册对某个IO的监听，当IO可以使用的时候，event demultiplexer来通知相应的handler。

### reactor

Reactor 的中心思想是众所周知的 I/O 多路复用:select,poll,epoll等。Reactor的一般工作过程是首先在Reactor中注册感兴趣事件，并在注册时候指定某个已定义的回调函数。当客户端发送请求时，在 Reactor中会触发刚才注册的事件，并调用对应的处理函数。在这一个处理回调函数中，一般会有数据接收、处理、回复请求等操作。

![](https://clouder123.oss-cn-beijing.aliyuncs.com/reactor01.png
)
Reactor包含如下角色：

* Handle 句柄；用来标识socket连接或是打开文件；
* Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）
* Event Handler：事件处理接口
* Concrete Event Handler：实现应用程序所提供的特定事件处理逻辑；
* Reactor：反应器，定义一个接口，实现以下功能：
  1. 供应用程序注册和删除关注的事件句柄；
  2. 运行事件循环；
  3. 有就绪事件到来时，分发事件到之前注册的回调函数上处理；

以read为例，reactor做法是：

 * 某个事件处理者宣称它对某个socket上的读事件很感兴趣;
 * 事件分离者等着这个事件的发生;
 * 当事件发生了，事件分离器被唤醒，这负责通知先前那个事件处理者;
 * 事件处理者收到消息，于是去那个socket上读数据了. 如果需要，它再次宣称对这个socket上的读事件感兴趣，一直重复上面的步骤;

### proactor

从上面 Reactor 模式中，发现服务端数据的接收和发送都占用了用户状态（还有一种内核态），这样服务器的处理操作就在数据的读写上阻塞花费了时间，节省这些时间的办法是借助操作系统的异步读写；异步读写在调用的时候可以传递回调函数或者回送信号，当异步操作完毕，内核会自动调用回调函数或者发送信号。Proactor 就是这么做的，所以很依赖操作系统。

继续以读为例，proactor做法是：

* 处理器发起异步读操作，这就要求操作系统必须支持异步IO。这种情况下，处理无视IO就绪事件，它关注的是完成事件。
* 事件分离器等待完成事件
* 在分离等待过程中，操作系统充分利用并行的内核线程进行实际的读操作，并将结果放入用户自定义缓冲区，最后通知事件分离器操作完成。
* 事件分离器通知事件处理器。
* 事件处理器处理用户自定义缓冲区的数据，然后启动一个新的异步操作，并将控制权返还给事件分离器。

## 总结
可以看出，两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。


