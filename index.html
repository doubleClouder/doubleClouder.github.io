<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>clouder的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在学习的道路上不断成长。。">
<meta property="og:type" content="website">
<meta property="og:title" content="clouder的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="clouder的博客">
<meta property="og:description" content="在学习的道路上不断成长。。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="clouder的博客">
<meta name="twitter:description" content="在学习的道路上不断成长。。">
  
    <link rel="alternate" href="/atom.xml" title="clouder的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">clouder的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">在学习的道路上不断成长。。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-kafka-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/11/kafka-4/" class="article-date">
  <time datetime="2018-03-11T09:12:59.000Z" itemprop="datePublished">2018-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/11/kafka-4/">kafka学习笔记（四）-kafkaProducer NIO模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇的kafkaProducer分析中，我们知道kafka中的nio模型并没有使性能和易用性上都非常优秀的netty框架，而是自己封装了nio的调用。kafka client端的IO操作是通过NetworkClient来完成，NetworkClient底层封装了java NIO。</p>
<h1 id="producer网络模型"><a href="#producer网络模型" class="headerlink" title="producer网络模型"></a>producer网络模型</h1><p>上一篇内容中也提到，kafkaProducer线程会把消息放入本地队列，真正的IO操作是通过sender线程来完成的，sender作为最上层的接口，调用的是NetworkClient,NetworkClient调用Selector。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/kafka_nio.png" alt=""><br>上面展示了kafkaProducer网络模型的层次划分，从上往下依次为：最上层Sender调用层作为整个体系的入口，下面是Network接口层、Network层以及nio层。Sender调用NetworkClient，NetworkClient调用 Selector，而Selector底层封装了Java NIO的相关接口。</p>
<h2 id="Network层"><a href="#Network层" class="headerlink" title="Network层"></a>Network层</h2><p>NetworkClient作为网络层接口，真正的NIO封装是在NetWork层实现。下面我们看一下网络层的组件构成。</p>
<ul>
<li>kafkaChannel: 对nio的socketChannel的封装，只是中间多了一层代理TransportLayer，可以实现加密的channel.</li>
<li>NetworkSend/NetworkReceive是对ByteBuffer的封装，表示一次请求的数据包。</li>
<li>kafka selector：Kafka的Selector封装了NIO的Selector，内含一个NIO Selector对象。</li>
</ul>
<h3 id="kafka-selector"><a href="#kafka-selector" class="headerlink" title="kafka selector"></a>kafka selector</h3><p>org.apache.kafka.common.network.Selector构成如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Selector implements Selectable, AutoCloseable &#123;</div><div class="line"></div><div class="line">    public static final long NO_IDLE_TIMEOUT_MS = -1;</div><div class="line">    private static final Logger log = LoggerFactory.getLogger(Selector.class);</div><div class="line"></div><div class="line">    private final java.nio.channels.Selector nioSelector;</div><div class="line">    private final Map&lt;String, KafkaChannel&gt; channels;</div><div class="line">    private final List&lt;Send&gt; completedSends;</div><div class="line">    private final List&lt;NetworkReceive&gt; completedReceives;</div><div class="line">    private final Map&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt; stagedReceives;</div><div class="line">    private final Set&lt;SelectionKey&gt; immediatelyConnectedKeys;</div><div class="line">    private final Map&lt;String, KafkaChannel&gt; closingChannels;</div><div class="line">    private final Map&lt;String, ChannelState&gt; disconnected;</div><div class="line">    private final List&lt;String&gt; connected;</div><div class="line">    private final List&lt;String&gt; failedSends;</div><div class="line">    private final Time time;</div><div class="line">    private final SelectorMetrics sensors;</div><div class="line">    private final ChannelBuilder channelBuilder;</div><div class="line">    private final int maxReceiveSize;</div><div class="line">    private final boolean recordTimePerConnection;</div><div class="line">    private final IdleExpiryManager idleExpiryManager;</div></pre></td></tr></table></figure>
<p>可以看出kafka selector中还包括一个kafkaChannel的连接池。selector中包含几个重要的操作 send和poll。先来看下send.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Queue the given request for sending in the subsequent &#123;@link #poll(long)&#125; calls</div><div class="line">     * @param send The request to send</div><div class="line">     */</div><div class="line">    public void send(Send send) &#123;</div><div class="line">        String connectionId = send.destination();</div><div class="line">        if (closingChannels.containsKey(connectionId))</div><div class="line">            this.failedSends.add(connectionId);</div><div class="line">        else &#123;</div><div class="line">            KafkaChannel channel = channelOrFail(connectionId, false);</div><div class="line">            try &#123;</div><div class="line">                channel.setSend(send);</div><div class="line">            &#125; catch (CancelledKeyException e) &#123;</div><div class="line">                this.failedSends.add(connectionId);</div><div class="line">                close(channel, false);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根据数据包的目的地找到对应的channel,然后我们发现数据包并有通过channel发出来，而是通过channel.setSend()暂存在channel中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//kafkaChannel</div><div class="line">public void setSend(Send send) &#123;</div><div class="line">        if (this.send != null)</div><div class="line">        //这里如果channel的当前数据包不为空也就数据包还没有发出去，不能存放下一个，直接抛出异常</div><div class="line">            throw new IllegalStateException(&quot;Attempt to begin a send operation with prior send operation still in progress.&quot;);</div><div class="line">        this.send = send;</div><div class="line">        this.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出channel一次只能暂存一个数据包。暂存在channel之后，并注册一个写事件，poll就会进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void poll(long timeout) throws IOException &#123;</div><div class="line">        if (timeout &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;timeout should be &gt;= 0&quot;);</div><div class="line"></div><div class="line">        clear();</div><div class="line"></div><div class="line">        if (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())</div><div class="line">            timeout = 0;</div><div class="line"></div><div class="line">        /* check ready keys */</div><div class="line">        long startSelect = time.nanoseconds();</div><div class="line">        int readyKeys = select(timeout);</div><div class="line">        long endSelect = time.nanoseconds();</div><div class="line">        this.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</div><div class="line"></div><div class="line">        if (readyKeys &gt; 0 || !immediatelyConnectedKeys.isEmpty()) &#123;</div><div class="line">            pollSelectionKeys(this.nioSelector.selectedKeys(), false, endSelect);</div><div class="line">            pollSelectionKeys(immediatelyConnectedKeys, true, endSelect);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        addToCompletedReceives();</div><div class="line"></div><div class="line">        long endIo = time.nanoseconds();</div><div class="line">        this.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</div><div class="line"></div><div class="line">        // we use the time at the end of select to ensure that we don&apos;t close any connections that</div><div class="line">        // have just been processed in pollSelectionKeys</div><div class="line">        maybeCloseOldestConnection(endSelect);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   ...</div><div class="line"> private void pollSelectionKeys(Iterable&lt;SelectionKey&gt; selectionKeys,</div><div class="line">                                   boolean isImmediatelyConnected,</div><div class="line">                                   long currentTimeNanos) &#123;</div><div class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</div><div class="line">        while (iterator.hasNext()) &#123;</div><div class="line">            SelectionKey key = iterator.next();</div><div class="line">            iterator.remove();</div><div class="line">            KafkaChannel channel = channel(key);</div><div class="line">            long channelStartTimeNanos = recordTimePerConnection ? time.nanoseconds() : 0;</div><div class="line"></div><div class="line">            // register all per-connection metrics at once</div><div class="line">            sensors.maybeRegisterConnectionMetrics(channel.id());</div><div class="line">            if (idleExpiryManager != null)</div><div class="line">                idleExpiryManager.update(channel.id(), currentTimeNanos);</div><div class="line"></div><div class="line">            try &#123;</div><div class="line"></div><div class="line">                /* complete any connections that have finished their handshake (either normally or immediately) */</div><div class="line">                if (isImmediatelyConnected || key.isConnectable()) &#123;</div><div class="line">                    if (channel.finishConnect()) &#123;</div><div class="line">                        this.connected.add(channel.id());</div><div class="line">                        this.sensors.connectionCreated.record();</div><div class="line">                        SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line">                        log.debug(&quot;Created socket with SO_RCVBUF = &#123;&#125;, SO_SNDBUF = &#123;&#125;, SO_TIMEOUT = &#123;&#125; to node &#123;&#125;&quot;,</div><div class="line">                                socketChannel.socket().getReceiveBufferSize(),</div><div class="line">                                socketChannel.socket().getSendBufferSize(),</div><div class="line">                                socketChannel.socket().getSoTimeout(),</div><div class="line">                                channel.id());</div><div class="line">                    &#125; else</div><div class="line">                        continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* if channel is not ready finish prepare */</div><div class="line">                if (channel.isConnected() &amp;&amp; !channel.ready())</div><div class="line">                    channel.prepare();</div><div class="line"></div><div class="line">                /* if channel is ready read from any connections that have readable data */</div><div class="line">                if (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;</div><div class="line">                    NetworkReceive networkReceive;</div><div class="line">                    while ((networkReceive = channel.read()) != null)</div><div class="line">                        addToStagedReceives(channel, networkReceive);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* if channel is ready write to any sockets that have space in their buffer and for which we have data */</div><div class="line">                if (channel.ready() &amp;&amp; key.isWritable()) &#123;</div><div class="line">                    Send send = channel.write();</div><div class="line">                    if (send != null) &#123;</div><div class="line">                        this.completedSends.add(send);</div><div class="line">                        this.sensors.recordBytesSent(channel.id(), send.size());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* cancel any defunct sockets */</div><div class="line">                if (!key.isValid())</div><div class="line">                    close(channel, true);</div><div class="line"></div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                String desc = channel.socketDescription();</div><div class="line">                if (e instanceof IOException)</div><div class="line">                    log.debug(&quot;Connection with &#123;&#125; disconnected&quot;, desc, e);</div><div class="line">                else</div><div class="line">                    log.warn(&quot;Unexpected error from &#123;&#125;; closing connection&quot;, desc, e);</div><div class="line">                close(channel, true);</div><div class="line">            &#125; finally &#123;</div><div class="line">                maybeRecordTimePerConnection(channel, channelStartTimeNanos);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>pollSelectionKeys方法实现了我们熟悉的nio操作，通过Send send = channel.write()取出channel暂存的数据包并发送出来，然后将完成发送的结果加入输出结果集合。这里channel.write()仍然会返回一个send对象，由于write是非阻塞的，它并不会等整个数据包发送出去才返回，所以当channel.write完成整个数据包发送时会返回发送的send对象，如果没有完全发送出去则返回null。这里不能完全发送的情况时在NetworkClient中，往下传的是一个clientRequest,进入到seletor中，暂存在channel里面的也是一个完整的Send对象，但这个send对象交由底层write的时候并没有一次发送出去，需要多次调用write。</p>
<p>同样的，在接受的时候channel.read() ，一个ClientResponse也需要多次read,所以需要在while中read,并且将消息分包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;</div><div class="line">                    NetworkReceive networkReceive;</div><div class="line">                    while ((networkReceive = channel.read()) != null)</div><div class="line">                        addToStagedReceives(channel, networkReceive);</div><div class="line">                &#125;</div><div class="line">         ...</div><div class="line"> /**</div><div class="line">     * adds a receive to staged receives</div><div class="line">     */</div><div class="line">    private void addToStagedReceives(KafkaChannel channel, NetworkReceive receive) &#123;</div><div class="line">        if (!stagedReceives.containsKey(channel))</div><div class="line">            stagedReceives.put(channel, new ArrayDeque&lt;NetworkReceive&gt;());</div><div class="line"></div><div class="line">        Deque&lt;NetworkReceive&gt; deque = stagedReceives.get(channel);</div><div class="line">        deque.add(receive);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>selector通过一个queue存储每个数据分包直到一个response完全接收。我们再看看上层NetworkClient是如何处理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;</div><div class="line">        if (!abortedSends.isEmpty()) &#123;</div><div class="line">            // If there are aborted sends because of unsupported version exceptions or disconnects,</div><div class="line">            // handle them immediately without waiting for Selector#poll.</div><div class="line">            List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();</div><div class="line">            handleAbortedSends(responses);</div><div class="line">            completeResponses(responses);</div><div class="line">            return responses;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long metadataTimeout = metadataUpdater.maybeUpdate(now);</div><div class="line">        try &#123;</div><div class="line">            this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            log.error(&quot;Unexpected error during I/O&quot;, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // process completed actions</div><div class="line">        long updatedNow = this.time.milliseconds();</div><div class="line">        List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();</div><div class="line">        handleCompletedSends(responses, updatedNow);</div><div class="line">        //更新metaData</div><div class="line">        handleCompletedReceives(responses, updatedNow);</div><div class="line">        handleDisconnections(responses, updatedNow);</div><div class="line">        handleConnections();</div><div class="line">        handleInitiateApiVersionRequests(updatedNow);</div><div class="line">        handleTimedOutRequests(responses, updatedNow);</div><div class="line">        completeResponses(responses);</div><div class="line"></div><div class="line">        return responses;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>先来看下NetWorkClient的poll方法，上面提到selector的poll会把处理结果放入结果集，这里就是对这些结果集进行处理。在往上层看，从调用层sender的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">void run(long now) &#123;</div><div class="line">        if (transactionManager != null) &#123;</div><div class="line">            if (!transactionManager.isTransactional()) &#123;</div><div class="line">                // this is an idempotent producer, so make sure we have a producer id</div><div class="line">                maybeWaitForProducerId();</div><div class="line">            &#125; else if (transactionManager.hasInFlightRequest() || maybeSendTransactionalRequest(now)) &#123;</div><div class="line">                // as long as there are outstanding transactional requests, we simply wait for them to return</div><div class="line">                client.poll(retryBackoffMs, now);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // do not continue sending if the transaction manager is in a failed state or if there</div><div class="line">            // is no producer id (for the idempotent case).</div><div class="line">            if (transactionManager.hasFatalError() || !transactionManager.hasProducerId()) &#123;</div><div class="line">                RuntimeException lastError = transactionManager.lastError();</div><div class="line">                if (lastError != null)</div><div class="line">                    maybeAbortBatches(lastError);</div><div class="line">                client.poll(retryBackoffMs, now);</div><div class="line">                return;</div><div class="line">            &#125; else if (transactionManager.hasAbortableError()) &#123;</div><div class="line">                accumulator.abortUndrainedBatches(transactionManager.lastError());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long pollTimeout = sendProducerData(now);</div><div class="line">        client.poll(pollTimeout, now);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  private long sendProducerData(long now) &#123;</div><div class="line">        Cluster cluster = metadata.fetch();</div><div class="line">        // get the list of partitions with data ready to send</div><div class="line">        RecordAccumulator.ReadyCheckResult result = this.accumulator.ready(cluster, now);</div><div class="line"></div><div class="line">        // if there are any partitions whose leaders are not known yet, force metadata update</div><div class="line">        if (!result.unknownLeaderTopics.isEmpty()) &#123;</div><div class="line">            // The set of topics with unknown leader contains topics with leader election pending as well as</div><div class="line">            // topics which may have expired. Add the topic again to metadata to ensure it is included</div><div class="line">            // and request metadata update, since there are messages to send to the topic.</div><div class="line">            for (String topic : result.unknownLeaderTopics)</div><div class="line">                this.metadata.add(topic);</div><div class="line">            this.metadata.requestUpdate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // remove any nodes we aren&apos;t ready to send to</div><div class="line">        Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</div><div class="line">        long notReadyTimeout = Long.MAX_VALUE;</div><div class="line">        while (iter.hasNext()) &#123;</div><div class="line">            Node node = iter.next();</div><div class="line">            if (!this.client.ready(node, now)) &#123;</div><div class="line">                iter.remove();</div><div class="line">                notReadyTimeout = Math.min(notReadyTimeout, this.client.connectionDelay(node, now));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // create produce requests</div><div class="line">        Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = this.accumulator.drain(cluster, result.readyNodes,</div><div class="line">                this.maxRequestSize, now);</div><div class="line">        if (guaranteeMessageOrder) &#123;</div><div class="line">            // Mute all the partitions drained</div><div class="line">            for (List&lt;ProducerBatch&gt; batchList : batches.values()) &#123;</div><div class="line">                for (ProducerBatch batch : batchList)</div><div class="line">                    this.accumulator.mutePartition(batch.topicPartition);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;ProducerBatch&gt; expiredBatches = this.accumulator.expiredBatches(this.requestTimeout, now);</div><div class="line">        boolean needsTransactionStateReset = false;</div><div class="line">        // Reset the producer id if an expired batch has previously been sent to the broker. Also update the metrics</div><div class="line">        // for expired batches. see the documentation of @TransactionState.resetProducerId to understand why</div><div class="line">        // we need to reset the producer id here.</div><div class="line">        if (!expiredBatches.isEmpty())</div><div class="line">            log.trace(&quot;Expired &#123;&#125; batches in accumulator&quot;, expiredBatches.size());</div><div class="line">        for (ProducerBatch expiredBatch : expiredBatches) &#123;</div><div class="line">            failBatch(expiredBatch, -1, NO_TIMESTAMP, expiredBatch.timeoutException());</div><div class="line">            if (transactionManager != null &amp;&amp; expiredBatch.inRetry()) &#123;</div><div class="line">                needsTransactionStateReset = true;</div><div class="line">            &#125;</div><div class="line">            this.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (needsTransactionStateReset) &#123;</div><div class="line">            transactionManager.resetProducerId();</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sensors.updateProduceRequestMetrics(batches);</div><div class="line"></div><div class="line">        // If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately</div><div class="line">        // loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data</div><div class="line">        // that isn&apos;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes</div><div class="line">        // with sendable data that aren&apos;t ready to send since they would cause busy looping.</div><div class="line">        long pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</div><div class="line">        if (!result.readyNodes.isEmpty()) &#123;</div><div class="line">            log.trace(&quot;Nodes with data ready to send: &#123;&#125;&quot;, result.readyNodes);</div><div class="line">            // if some partitions are already ready to be sent, the select time would be 0;</div><div class="line">            // otherwise if some partition already has some data accumulated but not ready yet,</div><div class="line">            // the select time will be the time difference between now and its linger expiry time;</div><div class="line">            // otherwise the select time will be the time difference between now and the metadata expiry time;</div><div class="line">            pollTimeout = 0;</div><div class="line">        &#125;</div><div class="line">        sendProduceRequests(batches, now);</div><div class="line"></div><div class="line">        return pollTimeout;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>真正执行消息发送的逻辑在sendProducerData中，首先获取metaData中已经准备好的服务端节点client,通过client.ready(node, now)判断，这里借点准备好需要下面几个条件：</p>
<ol>
<li>metadata正常，不需要update</li>
<li>连接正常 connectionStates.isConnected(node)</li>
<li>channel是ready状态：这个对于PlaintextChannel， 一直返回true</li>
<li>当前该channel中，没有in flight request，所有请求都处理完了</li>
<li>当前该channel中，队列尾部的request已经完全发送出去, request.completed()，并且inflight request数目，没有超过设定的最大值，缺省为5.</li>
</ol>
<p>这里有一个问题，在response还没有回来的request，kafka是如何保存<br>request与response的对应关系的。答案在NetworkClient中，答案就是上面条件中的inFlightRequests</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//NetworkClient</div><div class="line">/* the set of requests currently being sent or awaiting a response */</div><div class="line">    private final InFlightRequests inFlightRequests;</div><div class="line">    </div><div class="line">final class InFlightRequests &#123;</div><div class="line"></div><div class="line">    private final int maxInFlightRequestsPerConnection;</div><div class="line">    private final Map&lt;String, Deque&lt;NetworkClient.InFlightRequest&gt;&gt; requests = new HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>在InFlightRequests中，存放了所有发出去，但是response还没有回来的request。request发出去的时候，入对列；response回来，就把相对应的request出队列。requests的key是消息的目的地。所以这就要求服务端必须保证消息的有序。即broker收到request的顺序是0，1，2。那么response必须是0，1，2。为此服务端实现了一种类似锁的机制mute/unmute，每当一个channel上面接收到一个request，这个channel就会被mute，然后等response返回之后，才会再unmute。这样就保证了同1个连接上面，同时只会有1个请求被处理。InFlightRequests还有一个作用就是判断连接是否失效。</p>
<h3 id="长连接维护"><a href="#长连接维护" class="headerlink" title="长连接维护"></a>长连接维护</h3><p>我们知道在所有的tcp长连接里，如果去判断连接是否失效，通过的做法是通过一个单独的线程去维护心跳，但是在kafka client里没有这样的线程，同样底层nio也无法告知你连接是否断开。kafka client里有三种方式来监测：</p>
<ul>
<li>所有的IO函数，connect, finishConnect, read, write都会抛IOException，因此任何时候，调用这些函数的时候，只要抛异常，就认为连接已经断开。</li>
<li>selectionKey.isValid()</li>
<li>上面提到的inflightRequests。所有发出去的request，都设置有一个response返回的时间。在这个时间内，response没有回来，就认为连接断了。</li>
</ul>
<p>在初始化建立连接的时候和每次selector poll的时候都会去检查连接是否断开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private final Map&lt;String, ChannelState&gt; disconnected;</div><div class="line">    private final List&lt;String&gt; connected;</div></pre></td></tr></table></figure>
<p>上面是kafka selector中保存连接状态的数据结构。</p>
<p>总结：</p>
<ol>
<li>Selector中的连接状态，在每次poll之前，会调用clear清空；在poll之后，收集。</li>
<li>Selector中的连接状态，会传给上层NetworkClient，用于它更新自己的连接状态</li>
<li>除了来自Selctor，NetworkClient自己内部的inflightRequests，也就是上面的手段3， 也用于检测连接状态。</li>
</ol>
<p>连接失效重连的操作在上层Sender中完成，上面判断一个节点是否ready中会发起失效连接的重连。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean ready(Node node, long now) &#123;</div><div class="line">        if (node.isEmpty())</div><div class="line">            throw new IllegalArgumentException(&quot;Cannot connect to empty node &quot; + node);</div><div class="line"></div><div class="line">        if (isReady(node, now))</div><div class="line">            return true;</div><div class="line"></div><div class="line">        if (connectionStates.canConnect(node.idString(), now))</div><div class="line">            // if we are interested in sending to a node and we don&apos;t have a connection to it, initiate one</div><div class="line">            initiateConnect(node, now);</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的是poll检查到连接断了返回给上层sender，sender只是发起连接，不会等到连接建立好了，再执行下面的代码。而已在poll之后，判断连接是否建立；在下1次或者下几次poll之前，可能连接才会建立好，ready才会返回true.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/11/kafka-4/" data-id="cjew9evh8000iuw2mioss8bee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-producer-nio" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/kafka-producer-nio/" class="article-date">
  <time datetime="2018-03-08T02:13:43.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/kafka-producer-nio/">kafka学习笔记（三）- KafkaProducer分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自kafka 0.8.2版本以后，kafka团队发布了新的java版本的client api以替代之前的scala版本的api。我们对kafka client端的分析都是建立在java版本的api基础之上。博主分析的kafka版本是0.11.0。</p>
<h2 id="Producer异步发送"><a href="#Producer异步发送" class="headerlink" title="Producer异步发送"></a>Producer异步发送</h2><p>0.8.2之前的scala客户端版本分别实现同步发送和异步发送两种方式。而在0.8.2之后的java版本中同步发送实际上也是通过异步发送间接实现的。</p>
<p>异步发送实际上就是在客户端维护一个消息缓冲区，producer发送消息的时候先将消息保存到消息缓冲区，然后后台发送线程会批量将消息缓冲区的消息发送到broker。<br><img src="http://osjt45oaj.bkt.clouddn.com/kafka_producer.png" alt=""><br>上图我们可以看出kafkaProducer在需要进行消息发送的时候，先把消息放到本地队列，然后由IO线程Sender取出队列的消息，异步的将消息发送给kafka broker。这里的sender其实还看了另外一件事，就是从broker获取meta信息，metaData就是broker,topic和partition之间的映射关系,每一个topic下partion有哪些；partion在broker上是如何分布的；partion的的leader和follwer信息。</p>
<p>从上面的producer的异布发送模型可以看出Sender每次从broker获取meta信息都会写到metaData中，然后kafkaProducer从metaData中获取这些信息，下面我们通过代码来看下metaData的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final class Metadata &#123;</div><div class="line"></div><div class="line">    private static final Logger log = LoggerFactory.getLogger(Metadata.class);</div><div class="line"></div><div class="line">    public static final long TOPIC_EXPIRY_MS = 5 * 60 * 1000;</div><div class="line">    private static final long TOPIC_EXPIRY_NEEDS_UPDATE = -1L;</div><div class="line"></div><div class="line">    //更新失败，下一次更新的时间</div><div class="line">    private final long refreshBackoffMs;</div><div class="line">    //过期时间，也即每隔多久需要更新一次。默认10分钟</div><div class="line">    private final long metadataExpireMs;</div><div class="line">    //成功更新，版本号递增</div><div class="line">    private int version;</div><div class="line">    //上一次更新时间</div><div class="line">    private long lastRefreshMs;</div><div class="line">    //上一次成功更新时间</div><div class="line">    private long lastSuccessfulRefreshMs;</div><div class="line">    //集群信息</div><div class="line">    private Cluster cluster;</div><div class="line">    private boolean needUpdate;</div><div class="line">    /* Topics with expiry time */</div><div class="line">    private final Map&lt;String, Long&gt; topics;</div><div class="line">    private final List&lt;Listener&gt; listeners;</div><div class="line">    private final ClusterResourceListeners clusterResourceListeners;</div><div class="line">    private boolean needMetadataForAllTopics;</div><div class="line">    private final boolean allowAutoTopicCreation;</div><div class="line">    private final boolean topicExpiryEnabled;</div><div class="line"></div><div class="line">    public Metadata(long refreshBackoffMs, long metadataExpireMs, boolean allowAutoTopicCreation) &#123;</div><div class="line">        this(refreshBackoffMs, metadataExpireMs, allowAutoTopicCreation, false, new ClusterResourceListeners());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>MetaData中包含一些metaData本身操作信息和集群信息Cluster。cluster中真正维护着上面所说的boker与topic/partition的映射关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public final class Cluster &#123;</div><div class="line"></div><div class="line">    private final boolean isBootstrapConfigured;</div><div class="line">    private final List&lt;Node&gt; nodes;</div><div class="line">    private final Set&lt;String&gt; unauthorizedTopics;</div><div class="line">    private final Set&lt;String&gt; internalTopics;</div><div class="line">    private final Node controller;</div><div class="line">    private final Map&lt;TopicPartition, PartitionInfo&gt; partitionsByTopicPartition;</div><div class="line">    private final Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic;</div><div class="line">    private final Map&lt;String, List&lt;PartitionInfo&gt;&gt; availablePartitionsByTopic;</div><div class="line">    private final Map&lt;Integer, List&lt;PartitionInfo&gt;&gt; partitionsByNode;</div><div class="line">    private final Map&lt;Integer, Node&gt; nodesById;</div><div class="line">    private final ClusterResource clusterResource;</div></pre></td></tr></table></figure>
<p>在MetaData中，所有的公共方法都是synchronized的，metaData的操作是同步的，所以在多个producer thread读，sender线程写的情况下不会出现线程安全问题。</p>
<p>清楚metaData的结构之后，我们继续看下Sender是什么，Sender是一个IO线程，负责与broker交互，那么它是何时创建的呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</div><div class="line">    private KafkaProducer(ProducerConfig config, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valueSerializer) &#123;</div><div class="line">        try &#123;</div><div class="line">            log.trace(&quot;Starting the Kafka producer&quot;);</div><div class="line">            </div><div class="line">  ····</div><div class="line">                       this.metadata.update(Cluster.bootstrap(addresses), Collections.&lt;String&gt;emptySet(), time.milliseconds());</div><div class="line">            ChannelBuilder channelBuilder = ClientUtils.createChannelBuilder(config);</div><div class="line">            Sensor throttleTimeSensor = Sender.throttleTimeSensor(metrics);</div><div class="line">            NetworkClient client = new NetworkClient(</div><div class="line">                    new Selector(config.getLong(ProducerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG),</div><div class="line">                            this.metrics, time, &quot;producer&quot;, channelBuilder),</div><div class="line">                    this.metadata,</div><div class="line">                    clientId,</div><div class="line">                    maxInflightRequests,</div><div class="line">                    config.getLong(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG),</div><div class="line">                    config.getLong(ProducerConfig.RECONNECT_BACKOFF_MAX_MS_CONFIG),</div><div class="line">                    config.getInt(ProducerConfig.SEND_BUFFER_CONFIG),</div><div class="line">                    config.getInt(ProducerConfig.RECEIVE_BUFFER_CONFIG),</div><div class="line">                    this.requestTimeoutMs,</div><div class="line">                    time,</div><div class="line">                    true,</div><div class="line">                    apiVersions,</div><div class="line">                    throttleTimeSensor);</div><div class="line">            this.sender = new Sender(client,</div><div class="line">                    this.metadata,</div><div class="line">                    this.accumulator,</div><div class="line">                    maxInflightRequests == 1,</div><div class="line">                    config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG),</div><div class="line">                    acks,</div><div class="line">                    retries,</div><div class="line">                    this.metrics,</div><div class="line">                    Time.SYSTEM,</div><div class="line">                    this.requestTimeoutMs,</div><div class="line">                    config.getLong(ProducerConfig.RETRY_BACKOFF_MS_CONFIG),</div><div class="line">                    this.transactionManager,</div><div class="line">                    apiVersions);</div><div class="line">            String ioThreadName = &quot;kafka-producer-network-thread&quot; + (clientId.length() &gt; 0 ? &quot; | &quot; + clientId : &quot;&quot;);</div><div class="line">            this.ioThread = new KafkaThread(ioThreadName, this.sender, true);</div><div class="line">            this.ioThread.start();</div><div class="line">            this.errors = this.metrics.sensor(&quot;errors&quot;);</div><div class="line">            config.logUnused();</div><div class="line">            AppInfoParser.registerAppInfo(JMX_PREFIX, clientId);</div><div class="line">            log.debug(&quot;Kafka producer started&quot;);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">            // call close methods if internal objects are already constructed this is to prevent resource leak. see KAFKA-2121</div><div class="line">            close(0, TimeUnit.MILLISECONDS, true);</div><div class="line">            // now propagate the exception</div><div class="line">            throw new KafkaException(&quot;Failed to construct kafka producer&quot;, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>kafkaProducer的初始化过程是一些序列化规则，压缩类型，监控等基础配置的生成以及sender线程的创建，我们继续看下sender线程具体的动作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void run(long now) &#123;</div><div class="line">        if (transactionManager != null) &#123;</div><div class="line">            if (!transactionManager.isTransactional()) &#123;</div><div class="line">                // this is an idempotent producer, so make sure we have a producer id</div><div class="line">                maybeWaitForProducerId();</div><div class="line">            &#125; else if (transactionManager.hasInFlightRequest() || maybeSendTransactionalRequest(now)) &#123;</div><div class="line">                // as long as there are outstanding transactional requests, we simply wait for them to return</div><div class="line">                client.poll(retryBackoffMs, now);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在sender run方法中我们关注client.poll()这一行，前面transactionManager跟事务性producer相关，这里我们不关注。<br>client.poll()是调的NetworkClient的poll()方法，这是kafka客户端网络通信的的封装，封装了NIO操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;</div><div class="line">        if (!abortedSends.isEmpty()) &#123;</div><div class="line">            // If there are aborted sends because of unsupported version exceptions or disconnects,</div><div class="line">            // handle them immediately without waiting for Selector#poll.</div><div class="line">            List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();</div><div class="line">            handleAbortedSends(responses);</div><div class="line">            completeResponses(responses);</div><div class="line">            return responses;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long metadataTimeout = metadataUpdater.maybeUpdate(now);</div><div class="line">        try &#123;</div><div class="line">            this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            log.error(&quot;Unexpected error during I/O&quot;, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // process completed actions</div><div class="line">        long updatedNow = this.time.milliseconds();</div><div class="line">        List&lt;ClientResponse&gt; responses = new ArrayList&lt;&gt;();</div><div class="line">        handleCompletedSends(responses, updatedNow);</div><div class="line">        //更新metaData</div><div class="line">        handleCompletedReceives(responses, updatedNow);</div><div class="line">        handleDisconnections(responses, updatedNow);</div><div class="line">        handleConnections();</div><div class="line">        handleInitiateApiVersionRequests(updatedNow);</div><div class="line">        handleTimedOutRequests(responses, updatedNow);</div><div class="line">        completeResponses(responses);</div><div class="line"></div><div class="line">        return responses;</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>handleCompletedReceives()是对broker response的处理handler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void handleCompletedReceives(List&lt;ClientResponse&gt; responses, long now) &#123;</div><div class="line">        for (NetworkReceive receive : this.selector.completedReceives()) &#123;</div><div class="line">            String source = receive.source();</div><div class="line">            InFlightRequest req = inFlightRequests.completeNext(source);</div><div class="line">            Struct responseStruct = parseStructMaybeUpdateThrottleTimeMetrics(receive.payload(), req.header,</div><div class="line">                throttleTimeSensor, now);</div><div class="line">            if (log.isTraceEnabled()) &#123;</div><div class="line">                log.trace(&quot;Completed receive from node &#123;&#125;, for key &#123;&#125;, received &#123;&#125;&quot;, req.destination,</div><div class="line">                    req.header.apiKey(), responseStruct.toString());</div><div class="line">            &#125;</div><div class="line">            AbstractResponse body = createResponse(responseStruct, req.header);</div><div class="line">            if (req.isInternalRequest &amp;&amp; body instanceof MetadataResponse)</div><div class="line">                metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);</div><div class="line">            else if (req.isInternalRequest &amp;&amp; body instanceof ApiVersionsResponse)</div><div class="line">                handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) body);</div><div class="line">            else</div><div class="line">                responses.add(req.completed(body, now));</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们关注metadataResponse的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">        public void handleCompletedMetadataResponse(RequestHeader requestHeader, long now, MetadataResponse response) &#123;</div><div class="line">            this.metadataFetchInProgress = false;</div><div class="line">            Cluster cluster = response.cluster();</div><div class="line">            // check if any topics metadata failed to get updated</div><div class="line">            Map&lt;String, Errors&gt; errors = response.errors();</div><div class="line">            if (!errors.isEmpty())</div><div class="line">                log.warn(&quot;Error while fetching metadata with correlation id &#123;&#125; : &#123;&#125;&quot;, requestHeader.correlationId(), errors);</div><div class="line"></div><div class="line">            // don&apos;t update the cluster if there are no valid nodes...the topic we want may still be in the process of being</div><div class="line">            // created which means we will get errors and no nodes until it exists</div><div class="line">            if (cluster.nodes().size() &gt; 0) &#123;</div><div class="line">                this.metadata.update(cluster, response.unavailableTopics(), now);</div><div class="line">            &#125; else &#123;</div><div class="line">                log.trace(&quot;Ignoring empty metadata response with correlation id &#123;&#125;.&quot;, requestHeader.correlationId());</div><div class="line">                this.metadata.failedUpdate(now);</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里真正执行Metadata的更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public synchronized void update(Cluster cluster, Set&lt;String&gt; unavailableTopics, long now) &#123;</div><div class="line">        Objects.requireNonNull(cluster, &quot;cluster should not be null&quot;);</div><div class="line"></div><div class="line">        this.needUpdate = false;</div><div class="line">        this.lastRefreshMs = now;</div><div class="line">        this.lastSuccessfulRefreshMs = now;</div><div class="line">        this.version += 1;</div><div class="line"></div><div class="line">        if (topicExpiryEnabled) &#123;</div><div class="line">            // Handle expiry of topics from the metadata refresh set.</div><div class="line">            for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = topics.entrySet().iterator(); it.hasNext(); ) &#123;</div><div class="line">                Map.Entry&lt;String, Long&gt; entry = it.next();</div><div class="line">                long expireMs = entry.getValue();</div><div class="line">                if (expireMs == TOPIC_EXPIRY_NEEDS_UPDATE)</div><div class="line">                    entry.setValue(now + TOPIC_EXPIRY_MS);</div><div class="line">                else if (expireMs &lt;= now) &#123;</div><div class="line">                    it.remove();</div><div class="line">                    log.debug(&quot;Removing unused topic &#123;&#125; from the metadata list, expiryMs &#123;&#125; now &#123;&#125;&quot;, entry.getKey(), expireMs, now);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (Listener listener: listeners)</div><div class="line">            listener.onMetadataUpdate(cluster, unavailableTopics);</div><div class="line"></div><div class="line">        String previousClusterId = cluster.clusterResource().clusterId();</div><div class="line"></div><div class="line">        if (this.needMetadataForAllTopics) &#123;</div><div class="line">            // the listener may change the interested topics, which could cause another metadata refresh.</div><div class="line">            // If we have already fetched all topics, however, another fetch should be unnecessary.</div><div class="line">            this.needUpdate = false;</div><div class="line">            this.cluster = getClusterForCurrentTopics(cluster);</div><div class="line">        &#125; else &#123;</div><div class="line">            this.cluster = cluster;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // The bootstrap cluster is guaranteed not to have any useful information</div><div class="line">        if (!cluster.isBootstrapConfigured()) &#123;</div><div class="line">            String clusterId = cluster.clusterResource().clusterId();</div><div class="line">            if (clusterId == null ? previousClusterId != null : !clusterId.equals(previousClusterId))</div><div class="line">                log.info(&quot;Cluster ID: &#123;&#125;&quot;, cluster.clusterResource().clusterId());</div><div class="line">            clusterResourceListeners.onUpdate(cluster.clusterResource());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        notifyAll();</div><div class="line">        log.debug(&quot;Updated cluster metadata version &#123;&#125; to &#123;&#125;&quot;, this.version, this.cluster);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是metadata的更新逻辑，实际上kafka实现了两种metadata的更新规则，可以通过producerConfig配置项来完成：</p>
<ul>
<li><p>周期性的更新: 每隔一段时间更新一次，这个通过 Metadata的lastRefreshMs, lastSuccessfulRefreshMs 这2个字段来实现<br>配置项为metadata.max.age.ms //缺省300000，即10分钟1次</p>
</li>
<li><p>失效检测，强制更新：检查到metadata失效以后，调用metadata.requestUpdate()强制更新。 requestUpdate()函数里面其实什么都没做，就是把needUpdate置成了false。每次poll的时候，都检查这2种更新机制，达到了，就触发更新。</p>
</li>
</ul>
<p>kafkaProducer中调用metadata.requestUpdate()的地方就是主动把metadata主动置为失效。分析以下场景会有此做法：</p>
<ul>
<li>与broker连接初始化的时候</li>
<li>poll数据的时候，连接断了</li>
<li>请求超时</li>
<li>消息发送时，有partition的leader没找到</li>
<li>返回的response和请求对不上的时候</li>
</ul>
<p>总之数据不能正常发送或者数据不同步时都人为metadata有问题，需要更新。</p>
<p>还有一点注意的是：更新的时候，是从metadata保存的所有Node，或者说Broker中，选负载最小的那个，也就是当前接收请求最少的那个。向其发送MetadataRequest请求，获取新的Cluster对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/kafka-producer-nio/" data-id="cjew9evhf000nuw2m0w4dzxlv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-zero-copy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/kafka-zero-copy/" class="article-date">
  <time datetime="2017-11-20T02:36:54.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/20/kafka-zero-copy/">kafka学习笔记（二）zero-copy使用分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  kafka作为分布式的MQ系统时一个最重要的特性就是高吞吐量、低延迟。kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒。每个topic可以分多个partition,kafka使用replication机制备份partition数据。Follower partition可以批量的从Leader partition复制数据，而且Leader充分利用磁盘顺序读以及zero copy机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。zero copy是nio重要特性之一，它极大提高数据传输效率，本文我们就来分析一下kafka中如果使用这一特性。</p>
<h1 id="zero-copy机制"><a href="#zero-copy机制" class="headerlink" title="zero copy机制"></a>zero copy机制</h1><p>  说到zero copy，我们先来看下传统io服务端对客户端的传输。对于读操作：jvm虚拟机一定会发送一个read（）操作系统级别的方法，由此会产生一个上下文的切换，从程序所在的用户空间切换至系统的内核空间，内核空间向磁盘空间请求数据，通过DMA直接内存访问的方式将数据读取到内核空间缓冲区，此时用户空间是无法直接使用的，所以下面会将这份缓冲数据原封不动的拷贝到用户空间，至此read操作就结束。期间有两次上下文的切换，和两次数据的拷贝。对于写操作：将文件读取之后需要发送给远端socket客户端。同样调用系统级别的write方法，需要将上述读到的用户空间的数据原封不动的拷贝到内核上的socket缓冲区，然后DMA 引擎将数据从该缓冲区传到协议引擎，这一次拷贝独立地、异步地发生 。我们可以发现在一次网络IO过程有着不必要的上下文切换和数据拷贝。</p>
<p> 因此操作系统对与IO的一种优化方式是对于读写操作：用户空间向操作系统发送sendfile()方法，后续的操作只会在内核空间完成。对于所有的读写操作将只会有两次的用户空间和内核空间切换，这种操作称为操作系统意义上的零拷贝。而最佳的实现方式是通过DMA的方式拷贝数据到内核缓冲区，将对应的文件描述符写到socket buffer中，包含了内核的缓冲区的地址和数据长度，并不需要将数据拷贝到socket buffer中，只用存文件描述符。最后协议引擎发送数据的时候，从kernel buffer和socket buffer里面读取数据，对于kernel buffer是真实数据的读取，而对于socket buffer是文件描述符的读取，通过gather操作最终一起发送给客户端。</p>
<p>在nio中通过java.nio.channels.FileChannel. transferTo()方法支持zerocopy技术。</p>
<h1 id="kafa中如何应用"><a href="#kafa中如何应用" class="headerlink" title="kafa中如何应用"></a>kafa中如何应用</h1><p>kafka中partition leader到follower的消息同步和consumer拉取partition中的消息都使用到zero cory。Cousumer从broker获取数据时直接使用了FileChannel.transferTo()，直接在内核态进行的channel到channel的数据传输。</p>
<p>下面通过代码分析一下kafka使用zero cory的流程。首先看下kafka.server.KafkaApis.handle方法，它是kafka业务逻辑处理的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def handle(request: RequestChannel.Request) &#123;</div><div class="line">       ApiKeys.forId(request.requestId) match &#123;</div><div class="line">        case ApiKeys.PRODUCE =&gt; handleProducerRequest(request)</div><div class="line">        case ApiKeys.FETCH =&gt; handleFetchRequest(request)</div></pre></td></tr></table></figure></p>
<p>进入handleFetchRequest方法，也即消费者获取消息的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">replicaManager.fetchMessages(  </div><div class="line">       fetchRequest.maxWait.toLong, </div><div class="line">      fetchRequest.replicaId, </div><div class="line">      fetchRequest.minBytes,  </div><div class="line">      authorizedRequestInfo,  </div><div class="line">      sendResponseCallback)</div></pre></td></tr></table></figure>
<p>ReplicaManager 包含所有主题的所有partition消息。大部分针对Partition的操作都是通过该类来完成的。进入fetchMessages中我们会发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val logReadResults = readFromLocalLog(fetchOnlyFromLeader, fetchOnlyCommitted, fetchInfo)</div></pre></td></tr></table></figure>
<p>这是真正获取broker数据的地方，内部通过Log对象调用log.read(offset, fetchSize, maxOffsetOpt)，这里的log就是segment log的抽象。进入read发现数据是从这里读到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val fetchInfo = entry.getValue.read(startOffset, maxOffset, maxLength, maxPosition)</div></pre></td></tr></table></figure>
<p>fetchInfo对象有一个成员是FileMessageSet，它表示用户在这个Partition这一次消费能够拿到的数据集合。FileMessageSet里面有一个很重要的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def writeTo(destChannel: GatheringByteChannel, writePosition: Long, size: Int): Int = &#123;</div><div class="line">    ......</div><div class="line">    </div><div class="line">    val bytesTransferred = (destChannel match &#123;</div><div class="line">      case tl: TransportLayer =&gt; tl.transferFrom(channel, position, count)</div><div class="line">      case dc =&gt; channel.transferTo(position, count, dc)</div><div class="line">    &#125;).toInt</div><div class="line">   </div><div class="line">    bytesTransferred</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>回到上面readFromLocalLog，获取到数据后会被包装成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val fetchPartitionData = logReadResults.mapValues(result =&gt;  FetchResponsePartitionData(result.errorCode, result.hw, result.info.messageSet))</div><div class="line">responseCallback(fetchPartitionData)</div></pre></td></tr></table></figure>
<p>fetchPartitionData包含了上面提到的FileMessageSet，里面有真正进行zero copy的tranferTo()方法。上面代码可以发现回调函数responseCallback的参数是fetchPartitionData。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def sendResponseCallback(responsePartitionData: Map[TopicAndPartition, FetchResponsePartitionData]) &#123;</div><div class="line">      val mergedResponseStatus = responsePartitionData ++ unauthorizedResponseStatus</div><div class="line"></div><div class="line">...</div><div class="line">      def fetchResponseCallback(delayTimeMs: Int) &#123;</div><div class="line">        val response = FetchResponse(fetchRequest.correlationId, mergedResponseStatus, fetchRequest.versionId, delayTimeMs)</div><div class="line">        requestChannel.sendResponse(new RequestChannel.Response(request, new FetchResponseSend(request.connectionId, response)))</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里可以发现FetchResponsePartitionData 会被封装成一个FetchResponseSend ,然后由requestChannel发送出去。因为Kafka完全应用是NIO的异步机制，我们继续看下数据如何发送到consumer端。</p>
<p>在SocketServer，也就是负责和所有的消费者打交道，建立连接的中枢里，会不断的进行poll操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">override def run() &#123;</div><div class="line">    startupComplete()</div><div class="line">    while(isRunning) &#123;</div><div class="line">      try &#123;</div><div class="line">        // setup any new connections that have been queued up</div><div class="line">        configureNewConnections()</div><div class="line">        // register any new responses for writing</div><div class="line">        processNewResponses()</div><div class="line">        try &#123;</div><div class="line">          selector.poll(300)</div><div class="line">        &#125; catch &#123;</div><div class="line">          case...</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>首先会注册新的连接，如果有的话。接着就是处理新的响应了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private def processNewResponses() &#123;</div><div class="line">    var curr = requestChannel.receiveResponse(id)</div><div class="line">    while(curr != null) &#123;</div><div class="line">      try &#123;</div><div class="line">        curr.responseAction match &#123;         </div><div class="line">          case RequestChannel.SendAction =&gt;</div><div class="line">            selector.send(curr.responseSend)</div><div class="line">            inflightResponses += (curr.request.connectionId -&gt; curr)</div><div class="line">          </div><div class="line">        &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">        curr = requestChannel.receiveResponse(id)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>requestChannel.receiveResponse 对应上面FetchResponseSend的requestChannel.sendResponse。这里selector.send会将FetchResponseSend注册一个WRITE事件到selector上。SocketServer 会poll队列，一旦对应的KafkaChannel 写操作ready了，就会调用KafkaChannel的write方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public Send write() throws IOException &#123;</div><div class="line">        if (send != null &amp;&amp; send(send)) </div><div class="line">     </div><div class="line">    ....</div><div class="line"> private boolean send(Send send) throws IOException &#123;</div><div class="line">        send.writeTo(transportLayer);</div><div class="line">        if (send.completed())</div><div class="line">            transportLayer.removeInterestOps(SelectionKey.OP_WRITE);</div><div class="line"></div><div class="line">        return send.completed();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>send方法的入参send对象就是上面我们注册的FetchResponseSend 对象。接着看下send.writeTo()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private val sends = new MultiSend(dest, JavaConversions.seqAsJavaList(fetchResponse.dataGroupedByTopic.toList.map &#123;</div><div class="line">    case(topic, data) =&gt; new TopicDataSend(dest, TopicData(topic,</div><div class="line">                                                     data.map&#123;case(topicAndPartition, message) =&gt; (topicAndPartition.partition, message)&#125;))</div><div class="line">    &#125;))</div><div class="line">override def writeTo(channel: GatheringByteChannel): Long = &#123;</div><div class="line">    .....    </div><div class="line">     written += sends.writeTo(channel)</div><div class="line">    ....</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以发现send是一个MultiSend对象，里面包含两个重要成员topicAndPartition.partition: 分区<br>message:FetchResponsePartitionData</p>
<p>最后进行writeTo的时候是通过上面提到的FileMessageSet的writeTo，其实最后是通过tl.transferFrom(channel, position, count) 来完成最后的数据发送的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public long transferFrom(FileChannel fileChannel, long position, long count) throws IOException &#123;</div><div class="line">        return fileChannel.transferTo(position, count, socketChannel);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  上述就是zero copy的介绍以及kafka中是如何对这一机制的合理应用和异步NIO来极大提高消息消费效率的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/20/kafka-zero-copy/" data-id="cjew9evhi000quw2mnk0xaqso" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/kafka-one/" class="article-date">
  <time datetime="2017-11-19T08:24:59.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/kafka-one/">kafka学习笔记（一）kafka简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   kafka最初有linkedIn公司研发，2011年开源，12年成为Apache软件基金会顶级开源项目。kafka是一种分布式的MQ系统，越来越来的公司使用kafka作为消息中间件，因为kafka有如下不可比拟的特性：</p>
<ul>
<li>强大的处理能力，kafka是基于磁盘的消息存储，并且以顺序读写访问磁盘，避免了随进读写的性能问题，因此，面对海量消息，kafka也可以高效的存储和查询。</li>
<li>kafka消息分区的方式提高并发能力，而且支持在线分区，易拓展。</li>
<li>kafka支持为每个分区创建多个副本，其中只有一个leader副本负责读写，其他副本负责有leader同步，副本会均匀的分布在集群的broker上，容灾能力优秀。</li>
<li>kafka支持批量读写消息，网络利用率高</li>
</ul>
<p>在高并发的系统中，服务拆分是为了突破性能瓶颈的一个有效手段，但是各服务之间数据传输的实时性和可靠性成为新的挑战，kafka体现了它的强大之处。</p>
<h1 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h1><p>了解kafka到底如何工作的之前，我们先来了解一些概念。</p>
<ul>
<li><p>消息:  最基本的数据单元，mafka中的消息由key和value组成。key的作用是根据一定的策略，将消息路由到指定的分区，key可以是null；value部分则是真正的消息体，producer会批量发送消息到kafka。</p>
</li>
<li><p>topic&amp;partition: 用于存储消息的逻辑概念，宏观上，kafka就是生产者推消息到topic，消费者poll其中的消息进行消费。每个topic划分成多个分区，kafka是以磁盘存储消息的，partition是消息物理上的分组，它实际上是topic下的一个存储目录，目录下的消息存储方式决定了partition是一个有序的队列。kafka保证同一partition的消息是有序的，但不保证partition之前的顺序。同一topic的不同分区会分配再不同的broker上，partition的命名规则为topic名+分区序号。分区是kafka水平拓展的基础，我们可以通过增加服务器并再其上分配partion的方式来增加kafka的并行处理能力。</p>
</li>
<li><p>segment partition由多个segment组成，物理上segment是partition目录上的真是存储消息的文件。segment file由两部分组成：index file和data file，segement文件命名规则是partition下的第一个segment从0开始，后续的每个offset是前一个segment的最后一条消息的offerset值。数值为64位long大小，前面用0填充。</p>
</li>
</ul>
<p><img src="http://osjt45oaj.bkt.clouddn.com/kafka-1.png" alt=""><br>上图是segment的index文件与data文件的映射关系，当要查找partition中offset为x值的消息时，先通过二分查找定位到x所在segment的index文件，然后在通过index中的稀疏索引定位到消息在long中偏移量。具体可参考<a href="https://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kafka文件存储机制那些事
</a></p>
<p>kafka采用顺序磁盘I/O,所以指向最新的segment追加消息，当超出segment大小限制时，kafka会创建新的segement。正是由于kafka基于磁盘的消息存储，所以无论消费者是否已经拉取消息，kafka都会一直保留这些消息，但是为了节省磁盘空间，kafka必须实现周期性地删除旧的消息，kafka实现了两种保留策略，一是根据消息保留的时间，当消息在kafka中保留超过指定时间，可以被删除，另一种是指定topic中消息的数据量，超过一定量删除旧的消息，kafka会启动一个后台线程，定时检查topic中的消息是否可以删除，当达到条件时，直接删除顺序最前的segment就可以了。</p>
<ul>
<li><p>副本</p>
<p>kafka中partition可以有多个副本，是对消息的一本备份策略。每个分区至少有一个副本，当分区中只有一个副本时，就只有leader副本。每个分区的副本集合都会选举出一个副本作为leader,选举策略采用多数同意的方式，所以kafka的副本允许N-1的不存活。</p>
</li>
<li><p>ISR集合</p>
</li>
</ul>
<p>ISR(In-Sync Replica)集合表示目前可用的分区副本集。ISR集合中的副本必须保证两个条件：1.维持与zk的连接。2.最后一条消息的offset与leader的差值不超过指定阀值。有两个参数可以决定是否将ISR移除ISR集合：replica.lag.max.messages和replica.lag.time.max，前者表明副本offset落后leader offset的最大消息数，后者表示follower向leader发送请求的最大时间间隔。如果再一定的周期内follower不能追赶上leader,可能是由于I/O问题导致follower追加复制消息慢于leader拉取速度，这种属于慢副本。还有一种是卡住副本，由于GC或者副本死亡导致follower停止发送复制请求。</p>
<ul>
<li>HW&amp;LEO</li>
</ul>
<p>HW(high watermark)表示消费者拉取消息的高水位，它标记了一个特殊的offset值，意思就是消费者只能拉取HW之前的消息，HW之后的消息对消费者不可见。当ISR集合中全部的follower都拉取的HW指定消息进行同步后，leader会递增HW的值。</p>
<p>LEO(log end offset)是当前副本的最后一条消息的offset。HW和LEO这两个值都是和ISR集合相关的，引用HW是为了避免消息提交后，follower还未拉取消息，leader跑的过快，此时leader宕机导致的消息丢失问题。但ISR集合有效避免了消息同步复制带来的延时问题，当Followe副本延迟过高时，leader副本被踢出ISR集合，消息已然可以快速提交，当leader宕机时，会选举ISR集合中的follower作为新的leader,这新的leader包含hw之前的所有消息，这样既保证的消息不会丢失，也解决的消息同步带来的影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/19/kafka-one/" data-id="cjew9evha000kuw2m6v0htog0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dynamic-proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/24/dynamic-proxy/" class="article-date">
  <time datetime="2017-09-24T03:07:38.000Z" itemprop="datePublished">2017-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/dynamic-proxy/">ASM初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>   随着aop技术的兴起，动态代理得到越来越广泛的应用。下面我们就来聊一聊在java中实现动态代理都有哪些方式，关于动态代理的介绍可参考博主之前的一篇文章，其中介绍了一下JDK动态代理的使用方法和原理简介<br><a href="http://www.clouder.top/2017/04/12/JDK-Dynamic-Proxy/" target="_blank" rel="external">JDK动态代理</a><br>。动态代理说白了就是再程序运行期间，动态的改变一个类的行为或者生成一个新的类。我们知道JVM通过字节码的二进制信息加载类的，类的初始化过程第一步就是把class文件里所代表的静态存储结构转化为方法区的运行数据结构，当然加载过程只会进行一次。所以要动态的改变类的行为就需要我们遵循JVM的规范生成新的字节码。<br><img src="http://osjt45oaj.bkt.clouddn.com/dynamicproxy.png" alt=""><br>上图是网上别人画的一个动态生成类的原理图，很清晰的展示了动态代理的基本原理，在运行期生成新的字节码，然后类加载器完成类的初始化过程得到新类。</p>
<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><p>下面我们来看一下如何在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。其实JDK提供了sun.misc.ProxyGenerator.generateProxyClass(String proxyName,class[] interfaces)底层方法来产生动态代理的字节码。<br>除此之外，但这种实现现在已开源的解决方案有ASM和javaassist。</p>
<p>ASM是一个Java字节码操控框架。ASM从class文件载入后，可以分析类信息，改变类的行为，也能够根据要求生成新类。它能够以二进制形式修改已有类或者动态生成类。ASM可以直接产生二进制class文件，也可以在类被加载入Java虚拟机之前动态改变类行为。</p>
<p>ASM在创建class字节码的过程中，操纵是底层JVM的汇编指令，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。对于这些内容可以参考《JAVA虚拟机规范》。asm字节码增强技术主要是用来反射的时候提升性能的，如果单纯用jdk的反射调用，性能是非常低下的，而使用字节码增强技术后反射调用的时间已经基本可以与直接调用相当了。asm是一个轻量级的字节码框架，他的jar包仅几十k，它的核心类有以下几个：</p>
<ul>
<li>ClassReader:根据字节码的规则解析编译过的class文件。</li>
<li>ClassWriter:对已解析的类进行增强，比如说修改类名、属性以及方法，以及生成新的类的字节码文件。</li>
<li>ClassAdapter:该类也实现了ClassVisitor接口，它将对它的方法调用委托给另一个ClassVisitor对象。</li>
</ul>
<p>我们可以先来看一下字节码的结构，这样可以很容易的理解ASM到底做了什么以及它为什么要这样设计。<br><img src="http://osjt45oaj.bkt.clouddn.com/asm02.png" alt=""><br>关于上图中各部分的含义看名字也能一目了然，这里重点说一下常量池部分，一个类的常量池占了它本身的绝大部分空间，常量池里除了包括字符串常量和数值常量，还包含指向字段和方法的引用。</p>
<p>编译后的字节码文件与源文件的不同的在于：<br>编译后的 java 类仅仅只 述一个类信息，但是一个 java 源文件可以包含几个java 类 ；<br>编译后的 java 类不包含注释；<br>编译后的 java 类不包含 package 和 import段，因此，在编译后的类中，所有的类型名称都必须使用全路径；<br>编译后的 java 类包含一个常量池段 。（asm隐藏了与常量池相关的细节）</p>
<p>字节码操作工具有：</p>
<ul>
<li>BCEL：Byte Code Engineering Library (BCEL)，这是Apache Software Foundation 的Jakarta 项目的一部分。BCEL是 Java classworking 最广泛使用的一种框架,它可以让您深入 JVM 汇编语言进行类操作的细节。BCEL与Javassist 有不同的处理字节码方法，BCEL在实际的JVM 指令层次上进行操作(BCEL拥有丰富的JVM 指令级支持)而Javassist 所强调的源代码级别的工作。</li>
<li>JBET：通过JBET(Java Binary Enhancement Tool )的API可对Class文件进行分解，重新组合，或被编辑。JBET也可以创建新的Class文件。JBET用一种结构化的方式来展现Javabinary (.class)文件的内容，并且可以很容易的进行修改。</li>
<li>javaassist：直接使用java编码，不需要了解jvm指令，其工作方式与 JVM 类装载器非常相似。</li>
</ul>
<p>ASM的优势在于：</p>
<ul>
<li>ASM 具有简单、设计良好的 API，这些 API 易于使用；</li>
<li>ASM 有非常良好的开发文档，以及可以帮助简化开发的 Eclipse 插件；</li>
<li>ASM 支持 Java 6(ASM3)、Java7(ASM4)、Java(ASM5)；</li>
<li>ASM 很小、很快、很健壮；</li>
<li>ASM 有很大的用户群，可以帮助新手解决开发过程中遇到的问题；</li>
<li>ASM 的开源许可可以让你几乎以任何方式使用它；</li>
</ul>
<p>不说废话了，下面来看一下ASM的核心接口，ClassVisitor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public interface ClassVisitor &#123;</div><div class="line">    void visit(int var1, int var2, String var3, String var4, String var5, String[] var6);</div><div class="line"> </div><div class="line">    void visitSource(String var1, String var2);</div><div class="line"> </div><div class="line">    void visitOuterClass(String var1, String var2, String var3);</div><div class="line"> </div><div class="line">    AnnotationVisitor visitAnnotation(String var1, boolean var2);</div><div class="line"> </div><div class="line">    void visitAttribute(Attribute var1);</div><div class="line"> </div><div class="line">    void visitInnerClass(String var1, String var2, String var3, int var4);</div><div class="line"> </div><div class="line">    FieldVisitor visitField(int var1, String var2, String var3, String var4, Object var5);</div><div class="line"> </div><div class="line">    MethodVisitor visitMethod(int var1, String var2, String var3, String var4, String[] var5);</div><div class="line"> </div><div class="line">    void visitEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ClassVisitor把类的字节码所包含的信息组织成一个树状结构，在访问类结构中简单的段时， 是通过调用一个独立的方法来实现的，该方法的参数就是该段相关的内容，该方法的返回值 为 void。对长度任意并且较复杂的段进行访问时，是通过一个初始化方法返回一个辅助的 visitor 接口来实现，例如 visitAnnotation，visitField 以及 visitMethod，它们都返回与之对应 的接口 AnnotationVisitor，FieldVisitor 以及 MethodVisitor。</p>
<p>对 ClassVisitor 接口中方法的调用必须遵循下面文档定义的顺序 ：<br>visit visitSource? visitOuterClass? ( visitAnnotation | visitAttribute )*( visitInnerClass | visitField | visitMethod )<em>  visitEnd (?表示至多1次，\</em>表示任意次数)<br>这其实很好理解，类的字节码是按照一定规则排列的。同样，对MethodVisitor接口中方法的调用必须遵循下面文档定义的顺序：<br>( visitTryCatchBlock | visitLabel | visitFrame | visitXxxInsn | visitLocalVariable | visitLineNumber )*<br>visitMaxs )?<br>visitEnd</p>
<p>解析一个已存在的类仅需要ClassReader这个组件，它对字节码的每一段解析都可以看成产生一个事件。ClassWriter实现了ClassVisitor接口，实现了ClassVisitor接口中每个visitxx方法，当捕获对应事件时，可以将字节码写到指定位置，ASM是可以看成一个观察者模式的实现，ClassReader可以接收一个ClassWriter作为它的观察者，当ClassReader解析字节码的每一段产生一个事件时，会触发ClassWriter中对应的visitxx方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">byte[] b1 = ...;ClassWriter cw = new ClassWriter();</div><div class="line">ClassReader cr = new ClassReader(b1);cr.accept(cw, 0);byte[] b2 = cw.toByteArray();</div></pre></td></tr></table></figure>
<p>上面的代码复制b1创建一个新的类b2,实际上是将一个字节数组复制到另一个字节数组。这个过程可能看起来意义不大，但是如果我们加上一个新的组件ClassAdapter那就会变得很有趣。ClassAdapter也是实现了ClassVisitor接口，它相当于一个事件过滤器，通过自定义visitxx方法，同样再获取ClassReader产生的事件时执行相应的visitxx方法，达到按照开发者意愿修改字节码的目的，最后将事件传给ClassWriter将修改后的字节码落地。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class ChangeVersionAdapter extends ClassAdapter &#123;public ChangeVersionAdapter(ClassVisitor cv) &#123; super(cv);&#125;@Overridepublic void visit(int version, int access, String name,String signature, String superName, String[] interfaces) &#123;cv.visit(V1_5, access, name, signature, superName, interfaces); &#125;&#125;</div></pre></td></tr></table></figure>
<p>上面代码中自定义了一个ClassAdapter,它只重写了visit方法，在visit方法中修改了类的版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte[] b1 = ...ClassReader cr = new ClassReader(b1);ClassWriter cw = new ClassWriter(cr, 0);ChangeVersionAdapter ca = new ChangeVersionAdapter(cw); cr.accept(ca, 0);byte[] b2 = cw.toByteArray();</div></pre></td></tr></table></figure>
<p>上面代码中ca只在字节码的version段触发了一个修改类版本号的动作，剩余部分都直接转发给ClassWriter。</p>
<p>ClassAdapter是事件的转发者，转化过程形成一条classReader-classAdapter-classWriter的转换链，但一个转换链条没必要是线性的，更复杂的情况是你可以编写一个 ClassVisitor，然后同时转发所有的方法调用给多个 ClassVisitor。<br><img src="http://osjt45oaj.bkt.clouddn.com/asm3.png" alt=""><br>这样需要开发者在整体性能和低耦合之间做一个权衡。上面就是asm的主要组件及大致原理，它实际上相当于做了一个字节码层面的aop,基于观察者模式的事件触发，原理很简单，掌握了它的规则，使用起来也并不难。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/24/dynamic-proxy/" data-id="cjew9evh7000fuw2mhyoqfb9q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mybatis-cache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/27/mybatis-cache/" class="article-date">
  <time datetime="2017-08-27T07:10:22.000Z" itemprop="datePublished">2017-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/mybatis-cache/">mybatis缓存体系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Mybatis基本概念"><a href="#Mybatis基本概念" class="headerlink" title="Mybatis基本概念"></a>Mybatis基本概念</h1><p>每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话。我们先来看下sqlSession的创建过程:<br><img src="http://osjt45oaj.bkt.clouddn.com/mybatis1.png" alt=""><br>关于mybatis的初始化过程，这里不做探讨，只看下mybatis对数据库的会话过程中涉及的核心对象。</p>
<ul>
<li>Configuration     mybatis配置信息（mybatis初始化过程实际就是创建Configuration对象的过程）</li>
<li>SqlSession        数据库会话</li>
<li>SqlSessionFactory 数据库会话创建工厂</li>
<li>Excutor          执行器，调度核心</li>
<li>StatementHandler     封装了JDBC Statement操作，如设置参数、将Statement结果集转换成List集合。</li>
<li>MappedStatement   一个<select|update|delete|insert>节点的抽象。</select|update|delete|insert></li>
<li>BoundSql  动态生成的SQL语句以及相应的参数信息。</li>
</ul>
<h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>Mybatis的缓存体系由一级缓存和二级缓存构成，我们先来分析下一级缓存。缓存的意义是显而易见的，可以提高响应速度和降低资源消耗，Mybatis一级缓存的设计初衷也是基于这点。在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库,而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。 为了解决这一问题，减少资源的浪费，MyBatis在SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。<br><img src="http://osjt45oaj.bkt.clouddn.com/QQ20161023-0.jpg" alt=""><br>mybatis执行数据curd操作是通过sqlSession完成。以查询为例，sqlSession的select操作最终交给执行器Excutor来完成，下面看下Excutor的query方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</div><div class="line">   //得到绑定sql</div><div class="line">   BoundSql boundSql = ms.getBoundSql(parameter);</div><div class="line">   //创建缓存Key</div><div class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</div><div class="line">   //查询</div><div class="line">   return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> @Override</div><div class="line"> public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</div><div class="line">   ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</div><div class="line">   //如果已经关闭，报错</div><div class="line">   if (closed) &#123;</div><div class="line">     throw new ExecutorException(&quot;Executor was closed.&quot;);</div><div class="line">   &#125;</div><div class="line">   //先清局部缓存，再查询。但仅查询堆栈为0，才清。为了处理递归调用</div><div class="line">   if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">     clearLocalCache();</div><div class="line">   &#125;</div><div class="line">   List&lt;E&gt; list;</div><div class="line">   try &#123;</div><div class="line">     //加一,这样递归调用到上面的时候就不会再清局部缓存了</div><div class="line">     queryStack++;</div><div class="line">     //先根据cachekey从localCache去查</div><div class="line">     list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</div><div class="line">     if (list != null) &#123;</div><div class="line">       //若查到localCache缓存，处理localOutputParameterCache</div><div class="line">       handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">     &#125; else &#123;</div><div class="line">       //从数据库查</div><div class="line">       list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     //清空堆栈</div><div class="line">     queryStack--;</div><div class="line">   &#125;</div><div class="line">   if (queryStack == 0) &#123;</div><div class="line">     //延迟加载队列中所有元素</div><div class="line">     for (DeferredLoad deferredLoad : deferredLoads) &#123;</div><div class="line">       deferredLoad.load();</div><div class="line">     &#125;</div><div class="line">     // issue #601</div><div class="line">     //清空延迟加载队列</div><div class="line">     deferredLoads.clear();</div><div class="line">     if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</div><div class="line">       //如果是STATEMENT，清本地缓存</div><div class="line">       clearLocalCache();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return list;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">//从数据库查</div><div class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</div><div class="line">  List&lt;E&gt; list;</div><div class="line">  //先向缓存中放入占位符</div><div class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</div><div class="line">  try &#123;</div><div class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">  &#125; finally &#123;</div><div class="line">    //最后删除占位符</div><div class="line">    localCache.removeObject(key);</div><div class="line">  &#125;</div><div class="line">  //加入缓存</div><div class="line">  localCache.putObject(key, list);</div><div class="line">  //如果是存储过程，参数也加入缓存</div><div class="line">  if (ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">    localOutputParameterCache.putObject(key, parameter);</div><div class="line">  &#125;</div><div class="line">  return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现query方法中首先会通过createCacheKey方法创建缓存key，得到的结果就是一级缓存中的键值。Mybatis对于其缓存key的生成规则： mappedStementId + offset + limit + SQL + queryParams + environment生成hashCode。，CacheKey会根据这些条件来区分每一个CacheKey。cacheKey中会保存key的hashCode,参数个数以及将参数保存在updateList中。可以发现，mybatis根据<select>标签所在的Mapper的Namespace+</select><select>标签的id属性、处理分页类RowBounds的limit和offset、sql语句、sql参数这几个条件来判断两次查询是否相同。</select></p>
<p>通过上面的代码我们可以发现一级缓存就是执行器BaseExcutor的一个成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected PerpetualCache localCache;</div></pre></td></tr></table></figure>
<p>进入PerpetualCache可以揭开一级缓存的真面目，实际上就是一个本地缓存hashMap.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class PerpetualCache implements Cache &#123;</div><div class="line"></div><div class="line">  private String id;</div><div class="line"></div><div class="line">  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>至此我们可以发现Mybatis一级缓存以单纯的HashMap做缓存，没有容量控制，是一个粗粒度的缓存，没有更新缓存和缓存过期的概念。只适用于一次SqlSession，而一次SqlSession中通常来说并不会有大量的查询操作，而且只要执行update操作（update、insert、delete），都会将这个SqlSession对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响JVM内存空间的问题；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//SqlSession.update/insert/delete会调用此方法</div><div class="line">@Override</div><div class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</div><div class="line">  ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</div><div class="line">  if (closed) &#123;</div><div class="line">    throw new ExecutorException(&quot;Executor was closed.&quot;);</div><div class="line">  &#125;</div><div class="line">  //update操作会清除所有缓存</div><div class="line">  clearLocalCache();</div><div class="line">  return doUpdate(ms, parameter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line">@Override</div><div class="line">  public void clearLocalCache() &#123;</div><div class="line">    if (!closed) &#123;</div><div class="line">      localCache.clear();</div><div class="line">      localOutputParameterCache.clear();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>总结下一级缓存存储过程：</p>
<ol>
<li>对于某个Select Statement，根据该Statement生成cacheKey。</li>
<li>判断在Local Cache中,该key是否用对应的数据存在。</li>
<li>如果命中，则跳过查询数据库，继续往下走。</li>
<li>如果没命中,去数据库中查询数据，得到查询结果,将cacheKey和查询到的结果作为key和value，放入Local Cache中,将查询结果返回。</li>
<li>判断缓存级别是否为STATEMENT级别，如果是的话，清空本地缓存。</li>
</ol>
<p>Mybatis一级缓存的生命周期和SqlSession一致。本质就是一个hashMap,<br>而且不同sqlSession的更新数据会引发脏数据问题，所以建议不使用一级缓存。<br>三种方式不走一级缓存：</p>
<ol>
<li><p>一级缓存的默认级别设定为Statement，即不使用一级缓存。\<setting name="localCacheScope" value="STATEMENT"></setting></p>
</li>
<li><p>\<select>标签中的flushCache属性设置为true</select></p>
</li>
<li><p>Mybatis的拦截器</p>
</li>
</ol>
<h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>在mybatis中，缓存的功能由根接口Cache定义，整个体系采用装饰器模式。数据存储和缓存的基本功能由perpetualCache实现，然后通过一系列的装饰器对perpetualCache进行缓存策略的方便控制。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/mybatis2.png" alt=""></p>
<ol>
<li>FifoCache：先进先出算法，缓存回收策略</li>
<li>LoggingCache：输出缓存命中的日志信息</li>
<li>LruCache：最近最少使用算法，缓存回收策略</li>
<li>ScheduledCache：调度缓存，负责定时清空缓存</li>
<li>SerializedCache：缓存序列化和反序列化存储</li>
<li>SoftCache：基于软引用实现的缓存管理策略</li>
<li>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</li>
<li>WeakCache：基于弱引用实现的缓存管理策略</li>
<li>特殊的装饰器TransactionalCache：事务性的缓存</li>
</ol>
<p>二级缓存默认关闭。若开启先在Configuration下增加  \<setting name="cacheEnabled" value="true">，然后在mapper映射文件增加<cache>或<cache-ref>节点  注解方式增加@CacheNamespace或者@CacheNamespaceRef()。</cache-ref></cache></setting></p>
<p>和cache体系差不多，mybatis执行器也是通过委托的方式实现执行器的灵活控制<br> <img src="http://osjt45oaj.bkt.clouddn.com/mybatis3.png" alt=""><br> 若二级缓存开启，则mybatis默认的执行器为CachingExecutor。<br> 流程为： 从二级缓存中进行查询 -&gt; [如果缓存中没有，委托给 BaseExecutor] -&gt; 进入一级缓存中查询 -&gt; [如果也没有] -&gt; 则执行 JDBC 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</div><div class="line">    throws SQLException &#123;</div><div class="line">  Cache cache = ms.getCache();</div><div class="line">  //只有通过&lt;cache/&gt;,&lt;cache-ref/&gt;或@CacheNamespace,@CacheNamespaceRef标记使用缓存的Mapper.xml或Mapper接口才会有二级缓存。</div><div class="line">  if (cache != null) &#123;</div><div class="line">    flushCacheIfRequired(ms);</div><div class="line">    if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</div><div class="line">      ensureNoOutParams(ms, parameterObject, boundSql);</div><div class="line">      @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</div><div class="line">      if (list == null) &#123;</div><div class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">        tcm.putObject(cache, key, list); // </div><div class="line">      &#125;</div><div class="line">      return list;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的tcm.putObject方法执行完之后缓存并没有真正的生效，这里只是记录了这次查询将要产生缓存变更，这时候相同的sql查询缓存是不会生效的。下面看下TransactionalCacheManager#putObject（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void putObject(Cache cache, CacheKey key, Object value) &#123;</div><div class="line">  getTransactionalCache(cache).putObject(key, value);</div><div class="line">&#125;</div><div class="line">private TransactionalCache getTransactionalCache(Cache cache) &#123;</div><div class="line">  TransactionalCache txCache = transactionalCaches.get(cache); </div><div class="line">  if (txCache == null) &#123;</div><div class="line">    txCache = new TransactionalCache(cache);</div><div class="line">    transactionalCaches.put(cache, txCache);</div><div class="line">  &#125;</div><div class="line">  return txCache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际只有执行了sqlSession的commit方法之后，缓存的变更会真正的被刷新到缓存中去，开始真正的发挥作用。因为sqlSession的commit会调到上面TransactionalCache的commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public void commit() &#123;</div><div class="line">  if (clearOnCommit) &#123;</div><div class="line">    delegate.clear();</div><div class="line">  &#125;</div><div class="line">  flushPendingEntries();</div><div class="line">  reset();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void rollback() &#123;</div><div class="line">  unlockMissedEntries();</div><div class="line">  reset();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void reset() &#123;</div><div class="line">  clearOnCommit = false;</div><div class="line">  entriesToAddOnCommit.clear();</div><div class="line">  entriesMissedInCache.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void flushPendingEntries() &#123;</div><div class="line">  for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</div><div class="line">    delegate.putObject(entry.getKey(), entry.getValue());</div><div class="line">  &#125;</div><div class="line">  for (Object entry : entriesMissedInCache) &#123;</div><div class="line">    if (!entriesToAddOnCommit.containsKey(entry)) &#123;</div><div class="line">      delegate.putObject(entry, null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，写操作也不是马上会清除缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public int update(MappedStatement ms, Object parameterObject) throws SQLException &#123;</div><div class="line">//默认刷新缓存</div><div class="line">   flushCacheIfRequired(ms);</div><div class="line">   return delegate.update(ms, parameterObject);</div><div class="line"> &#125;</div><div class="line">private void flushCacheIfRequired(MappedStatement ms) &#123;</div><div class="line">  Cache cache = ms.getCache();</div><div class="line">  if (cache != null &amp;&amp; ms.isFlushCacheRequired()) &#123;      </div><div class="line">    tcm.clear(cache);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结</p>
<ol>
<li>二级缓存是以namespace为单位，不同namespace下互不影响。</li>
<li>写操作会清空所在namespace下所有缓存。</li>
<li>一个namespace下操作多张表会引起脏数据问题。</li>
<li>正是由于Mybatis cache体制这种灵活的委托机制，我们可以借助外部缓存来自定义Mybatis的二级缓存。</li>
</ol>
<p>上面就是Mybatis的缓存体系，设计上很简单，也存在不少的坑，所以我们使用的时候还是自己实现或者借助外部缓存，让Mybatis只完成它的本职工作就好！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/27/mybatis-cache/" data-id="cjew9evhg000puw2mjkbtkszu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/redis-list/" class="article-date">
  <time datetime="2017-07-23T02:26:06.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/redis-list/">redis消息队列实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大家都知道redis相较同类产品memcache而言有着丰富的数据类型,这里我们稍微说一下redis中的list数据类型，list的容量是2^32-1个元素，它存储的是链表结构，链表的属性是不管整个链表有多大，它的头尾操作是非常快的，这就符合一个消息队列的特性，简单意义上的消息队列就是生产者从对头插数据，消费者从队尾取数据，所以我们可以用redis中的list来实现一个mq。但是要使用mq，用市面上成熟的消息中间件产品岂不是更好？如rabbitmq、kafka等，当然，如rabbitmq、kafka等，当然如果要保证高可用高性能高吞吐量的消息队列，自然是要考虑使用此类成熟的中间件，这也不在本文描述范畴。但redis作为消息队列的好处是可以对消息的收发做到一个灵活的控制，添加一些自定义的行为，比如给消息定义优先级，所以在一定的业务场景下，将redis作为消息队列不失为一种好的选择。那么到底要如何实现呢。下面我们就演示一下在spring中如何整合redis消息队列。</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class RedisMq &#123;</div><div class="line">    @Resource</div><div class="line">    protected RedisTemplate jedisTemplate;</div><div class="line"></div><div class="line">    public void sendToRedis(final String msg) &#123;</div><div class="line">        String listName = &quot;xxx&quot;;</div><div class="line">        jedisTemplate.opsForList().rightPush(listName, mag);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生产者的代码很简单，就是往redis的指定list的一端push一条消息。下面就看一下消费者一端如何想spring整合其他mq那样监听队列。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>初始化队列类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class InitializeQueue implements InitializingBean, DisposableBean &#123;</div><div class="line">    private QueueListener listener;</div><div class="line">    private RedisTemplate redisTemplate;</div><div class="line">    private static List&lt;RedisQueue&gt; listQ = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建启动redis连接并监听</div><div class="line">     */</div><div class="line">    public void createQueue() &#123;</div><div class="line">        //这里先获取所有要监听的redis list名</div><div class="line">        List keys = xxx;</div><div class="line">        if (keys != null) &#123;</div><div class="line">            for (String key : keys) &#123;</div><div class="line">                RedisQueue queue = new RedisQueue();</div><div class="line">                queue.setListener(listener);</div><div class="line">                queue.setRedisTemplate(redisTemplate);</div><div class="line">                queue.setKey(app.getAppName());</div><div class="line">                listQ.add(queue);</div><div class="line">                try &#123;</div><div class="line">                    queue.start();</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    log.error(&quot;启动redis异常!&#123;&#125;&quot;, e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public QueueListener getListener() &#123;</div><div class="line">        return listener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setListener(QueueListener listener) &#123;</div><div class="line">        this.listener = listener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RedisTemplate getRedisTemplate() &#123;</div><div class="line">        return redisTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setRedisTemplate(RedisTemplate redisTemplate) &#123;</div><div class="line">        this.redisTemplate = redisTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 销毁redis连接</div><div class="line">     *</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void destroy() throws Exception &#123;</div><div class="line">        for (RedisQueue queue : listQ) &#123;</div><div class="line">            queue.destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void afterPropertiesSet() throws Exception &#123;</div><div class="line">        //创建队列</div><div class="line">        createQueue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>队列监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public interface QueueListener&lt;T&gt; &#123;</div><div class="line">    public void onMessage(T message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class RedisQueueListener implements QueueListener&lt;String&gt; &#123;</div><div class="line">    private ExecutorService threadpool = Executors.newFixedThreadPool(10);</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onMessage(String value) &#123;</div><div class="line">        threadpool.execute(new MessageRunnable(value));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class MessageRunnable implements Runnable &#123;</div><div class="line">        private String msg</div><div class="line">        public MessageRunnable(String msg) &#123;</div><div class="line">            this.msg = msg;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            log.info(&quot;处理消息!&quot;);</div><div class="line">            //消息处理业务代码</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消息队列实例，当创建一个RedisQueue实例就会绑定redis中一个list，并一直从list的尾部取出数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line">public class RedisQueue&lt;T&gt; &#123;</div><div class="line">    private RedisTemplate redisTemplate;</div><div class="line">    private String key;</div><div class="line">    private int cap = Short.MAX_VALUE;//最大阻塞的容量，超过容量将会导致清空旧数据</div><div class="line">    private byte[] rawKey;</div><div class="line">    private RedisConnectionFactory factory;</div><div class="line">    private RedisConnection connection;//for blocking</div><div class="line">    private BoundListOperations&lt;String, T&gt; listOperations;//noblocking</div><div class="line">    private Lock lock = new ReentrantLock();//基于底层IO阻塞考虑</div><div class="line">    private QueueListener listener;//异步回调</div><div class="line">    private Thread listenerThread;</div><div class="line">    private boolean isClosed = false;</div><div class="line">    //组塞10分钟</div><div class="line">    private int  timeout = 600;</div><div class="line">    //休息时间</div><div class="line">    private int sleepTime = 1000;</div><div class="line">    //获取为null 次数</div><div class="line">    private int failCount = 30;</div><div class="line">    public void setRedisTemplate(RedisTemplate redisTemplate) &#123;</div><div class="line">        this.redisTemplate = redisTemplate;</div><div class="line">    &#125;</div><div class="line">    public void setListener(QueueListener listener) &#123;</div><div class="line">        this.listener = listener;</div><div class="line">    &#125;</div><div class="line">    public void setKey(String key) &#123;</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 启动监听</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public void start() throws Exception &#123;</div><div class="line">        factory = redisTemplate.getConnectionFactory();</div><div class="line">        connection = RedisConnectionUtils.getConnection(factory);</div><div class="line">        rawKey = redisTemplate.getKeySerializer().serialize(key);</div><div class="line">        listOperations = redisTemplate.boundListOps(key);</div><div class="line">        if(listener != null)&#123;</div><div class="line">            listenerThread = new ListenerThread();</div><div class="line">            listenerThread.setDaemon(false);</div><div class="line">            listenerThread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * blocking</div><div class="line">     * 队列尾部取数据</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public T takeFromTail(int timeout) throws InterruptedException&#123;</div><div class="line">        lock.lockInterruptibly();</div><div class="line">        try&#123;</div><div class="line">            List&lt;byte[]&gt; results = connection.bRPop(timeout, rawKey);</div><div class="line">            if(CollectionUtils.isEmpty(results))&#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            return (T)redisTemplate.getValueSerializer().deserialize(results.get(1));</div><div class="line">        &#125;finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T takeFromTail() throws InterruptedException&#123;</div><div class="line">        return takeFromTail(timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 从队列的头，插入</div><div class="line">     */</div><div class="line">    public void pushFromHead(T value)&#123;</div><div class="line">        listOperations.leftPush(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pushFromTail(T value)&#123;</div><div class="line">        listOperations.rightPush(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 队尾取出</div><div class="line">     */</div><div class="line">    public T removeFromHead()&#123;</div><div class="line">        return listOperations.leftPop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T removeFromTail()&#123;</div><div class="line">        return listOperations.rightPop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 队尾取出增加超时时间</div><div class="line">     */</div><div class="line">    public T takeFromHead(int timeout) throws InterruptedException&#123;</div><div class="line">        lock.lockInterruptibly();</div><div class="line">        try&#123;</div><div class="line">            List&lt;byte[]&gt; results = connection.bLPop(timeout, rawKey);</div><div class="line">            if(CollectionUtils.isEmpty(results))&#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            return (T)redisTemplate.getValueSerializer().deserialize(results.get(1));</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            System.out.println(e);</div><div class="line">            log.error(&quot;get the value fail!&quot;,e);</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T takeFromHead() throws InterruptedException&#123;</div><div class="line">        return takeFromHead(timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void destroy() throws Exception &#123;</div><div class="line">        if(isClosed)&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        shutdown();</div><div class="line">        RedisConnectionUtils.releaseConnection(connection, factory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void shutdown()&#123;</div><div class="line">        try&#123;</div><div class="line">            listenerThread.interrupt();</div><div class="line">        &#125;catch(Exception e)&#123;</div><div class="line">            //注销失败</div><div class="line">            log.error(&quot;注销失败!&quot;,e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class ListenerThread extends Thread &#123;</div><div class="line">        int count = 0;</div><div class="line">        @Override</div><div class="line">        public void run()&#123;</div><div class="line">            try&#123;</div><div class="line">                while(true)&#123;</div><div class="line">                    //超过一定次数 休眠一段时间再去获取信息</div><div class="line">                    if(count &gt; failCount)&#123;</div><div class="line">                        Thread.sleep(sleepTime);</div><div class="line">                        count = 0;</div><div class="line">                    &#125;</div><div class="line">                    log.info(&quot;开始消费!&quot;);</div><div class="line">                    T value = takeFromHead();</div><div class="line">                    log.info((String)value);</div><div class="line">                    //逐个执行</div><div class="line">                    if(value != null)&#123;</div><div class="line">                        try&#123;</div><div class="line">                            listener.onMessage(value);</div><div class="line">                        &#125;catch(Exception e)&#123;</div><div class="line">                            log.error(&quot;处理消息错误!&quot;,e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;else&#123;</div><div class="line">                        count ++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                //处理消息错误</div><div class="line">                log.error(&quot;线程获取消息错误!&quot;,e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        if (obj instanceof RedisQueue) &#123;</div><div class="line">            RedisQueue queue = (RedisQueue) obj;</div><div class="line">            return queue.key.equals(this.key);</div><div class="line">        &#125;</div><div class="line">        return super.equals(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后在Spring上下文中将注入，大功告成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;initializeQueue&quot; class=&quot;com.clouder.redis.InitializeQueue&quot;&gt;</div><div class="line">        &lt;property name=&quot;listener&quot; ref=&quot;redisQueueListener&quot;&gt;&lt;/property&gt;</div><div class="line">        &lt;property name=&quot;redisTemplate&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>上述就是spring中整合redis list实现消息队列的过程。总结一下，创建一个队列初始化类注入spring上下文中随spring启动创建实例，初始化类中根据要监听的队列名创建队列实例，RedisQueue实例中启动后台线程从redis list中取出消息调用redis监听器的onMessage方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/23/redis-list/" data-id="cjew9evhn000yuw2m9e25k5ej" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RateLimiter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/14/RateLimiter/" class="article-date">
  <time datetime="2017-07-14T10:24:32.000Z" itemprop="datePublished">2017-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/14/RateLimiter/">接口限流之RateLimiter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>   对于高并发的系统而言，缓存、限流和降级是保证服务可用的三大利器。由于缓存的性能越来越高，对于系统能抗住高并发流量的作用自然不必多说；熔断和降级是保证服务可用的最后一道屏障，它是在下游服务故障或者系统负荷过高时不得不做的处理，通过一些mock的处理让服务暂时看起来可用，待高峰过后重新恢复。但在有些场景下，可以用来控制服务的请求速率，如双十一和12306的限流。</p>
<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p>  常见的限流算法有漏桶算法和令牌桶算法。<br>  <img src="http://osjt45oaj.bkt.clouddn.com/leaky_bucket.GIF" alt=""><br>上图可以直观的表现出漏桶算法的思想，请求可以看成水流，以一定速率的出水进入漏桶中，然后漏桶以一定的速率出水，当水流入速度过大会溢出，漏桶算法会强行限制数据的传输速率。突发流量会被限制成一个稳定的流量，如果漏桶溢出，那么数据包或者请求就会被丢弃。漏桶算法的缺陷是不能有效利用系统资源，即使不存在资源冲突，漏桶仍然已恒定的速率流出，故不能应对突发特性的流量。<br><img src="http://osjt45oaj.bkt.clouddn.com/token_bucket.JPG" alt=""><br>令牌桶算法的原理是系统已恒定的速率往桶内放入令牌，请求过来需要先从桶内取得令牌然后请求被处理，如果没取到则拒绝服务。假设限制速率2r/s即一秒2个往桶中放入令牌，桶的容量为n,当一个a个字节的数据包到达时，将从桶中删除a个令牌，如果当前桶的令牌数小于a，则本次请求被限流；令牌桶的一个优点在于可以按需改变放入令牌的速率来应对突发性的流量。</p>
<h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><p>RateLimiter出自大名鼎鼎的guava包，它是令牌桶算法的一种实现。RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率。与Semaphore 相比，Semaphore 限制了并发访问的数量而不是使用速率。<br>考虑下面的场景：我们需要执行一堆任务，但我们希望任务的提交速率限制在最多1s一个。我们利用RateLimiter来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">final RateLimiter rateLimiter = RateLimiter.create(1);</div><div class="line">Executor threadPool = Excutors.newFixedThreadPool(10);    </div><div class="line"> void submitTasks(List tasks) &#123;</div><div class="line">        for (Runnable task : tasks) &#123;</div><div class="line">            rateLimiter.acquire(); // 需要等待拿到令牌</div><div class="line">            executor.execute(task);</div><div class="line">        &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>下面再来考虑一个抢购的场景对接口进行限流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">public class ActivityController &#123;</div><div class="line">    @Resource</div><div class="line">    private GoodService goodService;</div><div class="line"></div><div class="line">    RateLimiter rateLimiter = RateLimiter.create(10);</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/rush&quot;)</div><div class="line">    public Object rush(HttpServletRequest request) &#123;</div><div class="line">        rateLimiter.acquire();</div><div class="line">        if (goodService.update(object) &gt; 0) &#123;</div><div class="line">            return &quot;success&quot;;</div><div class="line">        &#125;</div><div class="line">        return &quot;fail&quot;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>RateLimiter用法十分简单，它主要提供了下面方法</p>
<ul>
<li>acquire() 从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求并返回等待时间。</li>
<li>acquire(int permits) 提供一个入参指定许可数。</li>
<li>create(double permitsPerSecond) 指定每秒多少许可创建RateLimiter。</li>
<li>setRate(double permitsPerSecond) 根据许可产生速率。</li>
<li>tryAcquire()/tryAcquire(int permits) 获取许可（指定许可数),非阻塞立即返回，无法获取返回false。</li>
</ul>
<p>上面列出RateLimiter的几个重要的方法，了解了令牌桶的原理很容易理解成RateLimiter起了一个线程以一个固定的速率给一个计数器比如AtomicInteger加数字，可是真的是这样吗？我们移步代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static RateLimiter create(double permitsPerSecond) &#123;</div><div class="line">        return create(RateLimiter.SleepingTicker.SYSTEM_TICKER, permitsPerSecond);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @VisibleForTesting</div><div class="line">    static RateLimiter create(RateLimiter.SleepingTicker ticker, double permitsPerSecond) &#123;</div><div class="line">        RateLimiter rateLimiter = new RateLimiter.Bursty(ticker, 1.0D);</div><div class="line">        rateLimiter.setRate(permitsPerSecond);</div><div class="line">        return rateLimiter;</div><div class="line">    &#125;    &#125;</div></pre></td></tr></table></figure>
<p>create方法没什么好说，创建一个RateLimiter,关于这里面的SleepingTicker的作用我们稍后再说。先来看一下acquire方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public double acquire(int permits) &#123;</div><div class="line">        checkPermits(permits);  //参数校验</div><div class="line">        Object var4 = this.mutex;</div><div class="line">        long microsToWait;</div><div class="line">        synchronized(this.mutex) &#123;</div><div class="line">        //计算请求需要让线程等待多少时间</div><div class="line">            microsToWait = this.reserveNextTicket((double)permits, this.readSafeMicros());</div><div class="line">        &#125;</div><div class="line"></div><div class="line"> this.ticker.sleepMicrosUninterruptibly(microsToWait);//阻塞线程</div><div class="line">        return 1.0D * (double)microsToWait / (double)TimeUnit.SECONDS.toMicros(1L);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面计算线程的等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private long reserveNextTicket(double requiredPermits, long nowMicros) &#123;</div><div class="line">        this.resync(nowMicros);  //重新设置下一次获取时间和存储的令牌数</div><div class="line">        long microsToNextFreeTicket = this.nextFreeTicketMicros - nowMicros; //需要等待的时间</div><div class="line">        double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits);//获得请求的令牌数和存储的令牌数中的较小值</div><div class="line">        double freshPermits = requiredPermits - storedPermitsToSpend;  //如果为0 表示本次请求令牌够用,大于0表示“欠”的令牌数</div><div class="line">        long waitMicros = this.storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (long)(freshPermits * this.stableIntervalMicros);  //计算欠的令牌数需要多久产生</div><div class="line">        this.nextFreeTicketMicros += waitMicros;  //下次获取的时间</div><div class="line">    this.storedPermits -= storedPermitsToSpend; //更新令牌数</div><div class="line">        return microsToNextFreeTicket;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">private void resync(long nowMicros) &#123;</div><div class="line">        if(nowMicros &gt; this.nextFreeTicketMicros) &#123;</div><div class="line">            this.storedPermits = Math.min(this.maxPermits, this.storedPermits + (double)(nowMicros - this.nextFreeTicketMicros) / this.stableIntervalMicros);</div><div class="line">            this.nextFreeTicketMicros = nowMicros;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>resync的方法作用是设置nextFreeTicketMicros和storedPermits；nextFreeTicketMicros表示下次获取的时间，初始化为0。每调用一次acquire()，nowMicros - nextFreeTicketMicros就是上次请求到这次请求中间发生的时间。如果当前时间比上一轮设置的下次获取的时间大（因为存在提前获取的情况，比如上次直接获取了10个，那上轮设置的nextFreeTicketMicros就是上一轮的时间+5s），那就计算这个中间理论上能生成多少的令牌。比如这中间隔了1秒钟，然后stableIntervalMicros=5000（稳定生成速度的情况下）,那么，就这中间就可以生成2个令牌。再加上它原先存储的storedPermits个，如果比maxPermits大，那最大也只能存maxPermits这么多。如果比maxPermits小，那就是storedPermits=原先存的+这中间生成的数量。同时记录下下次获取的时候需要减去的时间，也就是当前时间 （nextFreeTicketMicros ）。</p>
<p>  reserveNextTicket方法计算出的时间也是请求需要等待的时间。举个例子，假设在nowMicros=3这个时间点来了一个请求，需要5个令牌，当前时间点令牌数为2，假设计算出waitMicro=3,则nexFreeTicketMicors=3,当前storedPermits=-2;该请求需要等待3s后的一致性。再假设过了1s另一请求到来需要1个令牌，则根据nexFreeTicketMicors和storedPermits继续计算waitMicro获取阻塞时间。</p>
<p>  总结起来，RateLimiter并不是真的一直往某个地方放令牌，而是在每次acquire时候根据当前令牌数和下次获取令牌算去本次请求是否能执行，如果要等需要等待多长时间，设计上非常巧妙。当第一次调用accquire()的时候，resync会被执行，然后在accquire()中将nextFreeTicketMicros设置为当前时间。但是，还可以请求的令牌数和当前存储的令牌数进行比较。如果请求的令牌数很大，则会计算出生成这些多余的令牌需要的时间，并加在nextFreeTicketMicros上，从而保证下次调用accquire()的时候，根据nextFreeTicketMicros和当时的nowMicros相减，若&gt;0，则需要等到对应的时间。也就能应对流量的突增情况了。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/14/RateLimiter/" data-id="cjew9evgv0003uw2mn8ngldbh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/guava/">guava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-weak-gc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/09/weak-gc/" class="article-date">
  <time datetime="2017-07-09T01:54:45.000Z" itemprop="datePublished">2017-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/09/weak-gc/">weakHashMap与GC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>WeakHashMap结构上与HashMap比较类型,内部都是通过Entry[]数组来组织数据，只不过WeakHashMap的Entry[]有些特殊，它的继承体系结构是Entry-&gt;WeakReference-&gt;Reference，这种结构保证了WeakHashMap的功能。先来看下API文档中对WeakHashMa的描述：以弱键 实现的基于哈希表的 Map。在 WeakHashMap中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。</p>
<p>WeakHashMap的行为取决于垃圾回收器的动作。由于垃圾回收器是由jvm调度的，gc可以发生在WeakHashMap对象生命周期的任何时候，所以WeakHashMap的表现为，即使对 WeakHashMap 实例进行同步，并且没有调用任何赋值方法，在一段时间后 size 方法也可能返回较小的值，对于 isEmpty 方法，可以先返回true，然后返回true，对于给定的键，containsKey方法返回true,然后返回false，对于给定的键,get方法返回一个值,但接着返回null。总而言之就是只要在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。</p>
<h1 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h1><p>深入了解WeakHashMap之前，我们必须对java中的几种引用类型有着明确的认识：</p>
<ul>
<li><p>强引用</p>
<p>强引用是相对其他类型引用而言的。如果一个对象具有强引用，GC绝不会回收它，当内存空间不足时，JVM宁愿抛出OOM。new出来的对象是典型的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//强引用</div><div class="line">Object StrongReference = new Object();</div></pre></td></tr></table></figure>
</li>
<li><p>软引用</p>
<p>如果一个对象具有软引用，当内存空间不足，GC会回收这些对象的内存，通常可以使用软引用构建敏感数据的缓存。SoftReference中还有个timestamp字段，表示软引用还可以通过设定时间戳进行回收。软引用可以通过get方法获取强引用。声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//SoftReference</div><div class="line">SoftReference&lt;Object&gt; sr = new SoftReference&lt;~&gt;(new Object());</div><div class="line">Object StrongReference = (Object) SoftRerence.get();</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>弱引用</p>
<p>如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存，使用弱引用 构建非敏感数据的缓存。声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//WeakReference</div><div class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;~&gt;(new Object());</div></pre></td></tr></table></figure>
</li>
<li><p>虚引用</p>
<p>如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收，虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列联合使用，虚引用主要用来跟踪对象被垃圾回收的活动。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  //PhantomReference</div><div class="line">PhantomReference&lt;Object&gt; phantomReference=new PhantomReference&lt;Object&gt;(new User(),new ReferenceQueue&lt;Object&gt;());</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="WeakHashMap与GC"><a href="#WeakHashMap与GC" class="headerlink" title="WeakHashMap与GC"></a>WeakHashMap与GC</h1><p>前面我们讲到WeakHashMap中Entry[]有着Entry-&gt;WeakReference-&gt;Reference这样一个继承结构，我们先来看下Reference类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private static Lock lock = new Lock();</div><div class="line"></div><div class="line"></div><div class="line">/* List of References waiting to be enqueued.  The collector adds</div><div class="line"> * References to this list, while the Reference-handler thread removes</div><div class="line"> * them.  This list is protected by the above lock object. The</div><div class="line"> * list uses the discovered field to link its elements.</div><div class="line"> */</div><div class="line">private static Reference&lt;Object&gt; pending = null;</div><div class="line"></div><div class="line">/* High-priority thread to enqueue pending References</div><div class="line"> */</div><div class="line">private static class ReferenceHandler extends Thread &#123;</div><div class="line"></div><div class="line">    private static void ensureClassInitialized(Class&lt;?&gt; clazz) &#123;</div><div class="line">        try &#123;</div><div class="line">            Class.forName(clazz.getName(), true, clazz.getClassLoader());</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        // pre-load and initialize InterruptedException and Cleaner classes</div><div class="line">        // so that we don&apos;t get into trouble later in the run loop if there&apos;s</div><div class="line">        // memory shortage while loading/initializing them lazily.</div><div class="line">        ensureClassInitialized(InterruptedException.class);</div><div class="line">        ensureClassInitialized(Cleaner.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</div><div class="line">        super(g, name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            tryHandlePending(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是Reference类的部分代码，可以看到Reference中有一个全局的锁对象：lock;有一个静态变量pending;在静态代码块中启动一个ReferenceHandler线程，启动完成后处于wait状态，它在一个Lock同步锁模块中等待。那么WeakHashMap中key/value如何自动回收跟这些有什么关系呢。</p>
<p>我们假设JVM使用cms收集器（使用其他收集器对于弱引用的回收原理相同）。JVM 在进行CMS GC的时候，会创建一个ConcurrentMarkSweepThread（简称CMST）线程去进行GC，ConcurrentMarkSweepThread线程被创建的同时会创建一个SurrogateLockerThread（简称SLT）线程并且启动它，SLT启动之后，处于等待阶段。CMST开始GC时，会发一个消息给SLT让它去获取Java层Reference对象的全局锁：Lock。 直到CMS GC完毕之后，JVM 会将WeakHashMap中所有被回收的对象所属的WeakReference容器对象放入到Reference 的pending属性当中（每次GC完毕之后，pending属性基本上都不会为null了），然后通知SLT释放并且notify全局锁:Lock。此时激活了ReferenceHandler线程的run方法，使其脱离wait状态，开始工作了。ReferenceHandler这个线程会将pending中的所有WeakReference对象都移动到它们各自的列队当中，比如当前这个WeakReference属于某个WeakHashMap对象，那么它就会被放入相应的ReferenceQueue列队里面（该列队是链表结构）。 当我们下次从WeakHashMap对象里面get、put数据或者调用size方法的时候，WeakHashMap就会将ReferenceQueue列队中的WeakReference一一poll出来去和Entry[]数据做比较，如果发现相同的，则说明这个Entry所保存的对象已经被GC掉了，那么将Entry[]内的Entry对象剔除掉，这样就完成的key/value的自动回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line">private final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p>这是WeakHashMap中的ReferenceQueue定义，注释就可以知道这是用来清除WeakEntries的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Expunges stale entries from the table.</div><div class="line">    */</div><div class="line">   private void expungeStaleEntries() &#123;</div><div class="line">       for (Object x; (x = queue.poll()) != null; ) &#123;</div><div class="line">           synchronized (queue) &#123;</div><div class="line">               @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                   Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">               int i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">               Entry&lt;K,V&gt; prev = table[i];</div><div class="line">               Entry&lt;K,V&gt; p = prev;</div><div class="line">               while (p != null) &#123;</div><div class="line">                   Entry&lt;K,V&gt; next = p.next;</div><div class="line">                   if (p == e) &#123;</div><div class="line">                       if (prev == e)</div><div class="line">                           table[i] = next;</div><div class="line">                       else</div><div class="line">                           prev.next = next;</div><div class="line">                       // Must not null out e.next;</div><div class="line">                       // stale entries may be in use by a HashIterator</div><div class="line">                       e.value = null; // Help GC</div><div class="line">                       size--;</div><div class="line">                       break;</div><div class="line">                   &#125;</div><div class="line">                   prev = p;</div><div class="line">                   p = next;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>expungeStaleEntries方法描述了如何清除，getTable,size等方法会首先调用该方法。以上就是弱引用的清除过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/09/weak-gc/" data-id="cjew9evhy0018uw2m5pp7chfe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-obejct-struct" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/04/obejct-struct/" class="article-date">
  <time datetime="2017-07-04T11:49:46.000Z" itemprop="datePublished">2017-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/04/obejct-struct/">对象内存布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  关于jvm中对象是如何分配内存的，在<a href="https://doubleclouder.github.io/2017/07/03/new-object-1/" target="_blank" rel="external">jvm源码分析之内存分配</a>中已经做过分析，现在我们就来讨论一下内存分配之后是如何布局的，简单的讲就是分配的内存区域里面到底存的是什么。</p>
<p> <img src="http://osjt45oaj.bkt.clouddn.com/struct1.png" alt=""><br> 上图引用自《java虚拟机精讲》。图中可以一目了然的看出对象的内存布局。存储对象实例信息的内存布局主要有两部分构成：对象头和实例数据以及padding区域。</p>
<ul>
<li>对象头：分成两部分Mark Word和元数据指针。Mark Word主要用于存储对象运行时的数据信息。比如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。而元数据指针则是指向方法区中目标类的类型信息，通过元数据指针可以指明当年对象是哪个类的实例。</li>
<li>实例数据：主要用于存储定义在当前对象中的各种类型的字段信息（包括派生于超类的字段）。</li>
<li>padding区：仅仅起着占位符的作用，jvm要求对象大小必须是8的倍数，若不是需要填充补齐，它不是必要存在的。</li>
</ul>
<p>当理解了Java对象在内存中如何存储之后，接下来我们看下jvm中是如何表达java类和对象实例的，底层jvm需要一套完整的内部对象表示机制，这种机制称为OOP-Klass模型，OOP(Ordinay Object Pionter)对象指针用于描述实例对象，而Klass则是用于描述对象实例的类型，对应上层java中的Class(之所以命名为Klass，是因为Class是c++中的关键字)。OOP与Klass是两个相互独立又彼此关联的模块。在JVM中对象头由OOP对象instanceOopDesc来表示，对象头中元数据指针锁指向的当前对象的目标类型是由Klass中的instanceKlass表示。栈中本地变量表中的引用变量指向堆上InstanceOopDesc对象，而instanceOopDesc对象持有只有instanceKlass的地址指针，如下图所示：</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/struct2.png" alt=""><br>下面重点分析一下mark word和实例数据部分。</p>
<h1 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h1><p>-<br>Mark Word具有非固定的数据结构，以便在极小的空间内存储尽量多的信息。JVM可以通过Java对象的元数据确定对象长度，但是对于数组不行。如果对象是一个数组，对象头必须有一块儿用于记录数组长度的数据，这么做的目的是gc扫描时会根据对象头直接确定下一个对象的地址，不需要扫描整个对象空间。对于对象头长度而言，32bit虚拟机一定是32bit+32bit，即8字节；64bit虚拟机若没有开启了压缩指针，是64bit+64bit，即16字节，若开启了压缩指针，是64bit+32bit，即12字节（不是8bit的倍数）<br>-XX:+UseCompressedOops：开启压缩指针。</p>
<h1 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h1><p>-<br>上面讲到实例数据部分存的是对象的各种类型的字段信息，包括基本类型和引用类型。我们在定义一个java类的时候不会去考虑字段的顺序，例如类A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class A&#123;</div><div class="line">   double x;</div><div class="line">   float y;</div><div class="line">   int z;</div><div class="line">   long a;</div><div class="line">   String s;</div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是jvm在创建对象的时候会按照一定的顺序去排列这些字段，顺序如下：</p>
<ol>
<li>double/long       8byte</li>
<li>float/int         4byte</li>
<li>short/char        2byte</li>
<li>byte/boolean      1byte</li>
<li>oop        4/8byte</li>
</ol>
<p>jvm默认以这种顺序去排列字段，这样做的原因是cpu读取内存时是按寄存器的大小单位（64位机器为64bit）载入的，如果载入的数据横跨两个64bit,要操作该数据的话必须两次读取加上组合移位，会产生效率问题，甚至会引发异常，所以必须要求数据对齐,同时也可以节省内存。<br>这种顺序也是可以更改的。通过指定jvm参数-XX:fIeldsAllocationStyle=mode，缺省状态下，jvm默认mode=1,mode还可以为0和2。为0时oop位于前面；mode=2时会将当前类和超类的oop字段放在一起，mode为0或1时会将派生类和超类的基本按照上述规则排在一起，oop类型位置不变，mode=2则也会将oop类型放在一起。按照jvm代码的注释可能更清晰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mode=0,Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</div><div class="line">mode=1:Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</div><div class="line">mode=2:Fields allocation: oops fields in super and sub classes are together.</div></pre></td></tr></table></figure>
<p>相当mode=0和1，mode=2的优势是可以减少gc时创建的OopMapBlock对象的数量。OopMapBlock结构如下：<br><img src="http://osjt45oaj.bkt.clouddn.com/struct3.png" alt=""><br>我们都知道gc时需要从gc root对象开始定位所有的存活的对象，那么就需要根据引用链记录对象指针，而OopMapBlock对象就是用来存放对象指针的，它有两个字段offset(偏移量)和对象个数(count),如果oop是连续的，对于同一个对象只需要一个OopMapBlock对象记录oop开始位置的便宜量和oop的个数就ok,否则需要两个oopMapBlock。另外一个好处是连续的对象区域使得cache line的使用效率更高. 试想如果父对象和子对象的对象引用区域不连续, 而中间插入了原始类型字段的话, 那么在做GC对象扫描时, 很可能需要跨cache line读取才能完成扫描.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/04/obejct-struct/" data-id="cjew9evhk000tuw2m8iduc5kc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/guava/">guava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-IO/">java IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/guava/" style="font-size: 13.33px;">guava</a> <a href="/tags/java/" style="font-size: 16.67px;">java</a> <a href="/tags/java-IO/" style="font-size: 10px;">java IO</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/kafka/" style="font-size: 16.67px;">kafka</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/并发/" style="font-size: 20px;">并发</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/11/kafka-4/">kafka学习笔记（四）-kafkaProducer NIO模型</a>
          </li>
        
          <li>
            <a href="/2018/03/08/kafka-producer-nio/">kafka学习笔记（三）- KafkaProducer分析</a>
          </li>
        
          <li>
            <a href="/2017/11/20/kafka-zero-copy/">kafka学习笔记（二）zero-copy使用分析</a>
          </li>
        
          <li>
            <a href="/2017/11/19/kafka-one/">kafka学习笔记（一）kafka简介</a>
          </li>
        
          <li>
            <a href="/2017/09/24/dynamic-proxy/">ASM初探</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zhusheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>