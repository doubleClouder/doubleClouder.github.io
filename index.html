<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>clouder的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在学习的道路上不断成长。。">
<meta property="og:type" content="website">
<meta property="og:title" content="clouder的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="clouder的博客">
<meta property="og:description" content="在学习的道路上不断成长。。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="clouder的博客">
<meta name="twitter:description" content="在学习的道路上不断成长。。">
  
    <link rel="alternate" href="/atom.xml" title="clouder的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">clouder的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">在学习的道路上不断成长。。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-kafka-one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/kafka-one/" class="article-date">
  <time datetime="2017-11-19T08:24:59.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/kafka-one/">kafka学习笔记（一）kafka简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   kafka最初有linkedIn公司研发，2011年开源，12年成为Apache软件基金会顶级开源项目。kafka是一种分布式的MQ系统，越来越来的公司使用kafka作为消息中间件，因为kafka有如下不可比拟的特性：</p>
<ul>
<li>强大的处理能力，kafka是基于磁盘的消息存储，并且以顺序读写访问磁盘，避免了随进读写的性能问题，因此，面对海量消息，kafka也可以高效的存储和查询。</li>
<li>kafka消息分区的方式提高并发能力，而且支持在线分区，易拓展。</li>
<li>kafka支持为每个分区创建多个副本，其中只有一个leader副本负责读写，其他副本负责有leader同步，副本会均匀的分布在集群的broker上，容灾能力优秀。</li>
<li>kafka支持批量读写消息，网络利用率高</li>
</ul>
<p>在高并发的系统中，服务拆分是为了突破性能瓶颈的一个有效手段，但是各服务之间数据传输的实时性和可靠性成为新的挑战，kafka体现了它的强大之处。</p>
<h1 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h1><p>了解kafka到底如何工作的之前，我们先来了解一些概念。</p>
<ul>
<li><p>消息:  最基本的数据单元，mafka中的消息由key和value组成。key的作用是根据一定的策略，将消息路由到指定的分区，key可以是null；value部分则是真正的消息体，producer会批量发送消息到kafka。</p>
</li>
<li><p>topic&amp;partition: 用于存储消息的逻辑概念，宏观上，kafka就是生产者推消息到topic，消费者poll其中的消息进行消费。每个topic划分成多个分区，kafka是以磁盘存储消息的，partition是消息物理上的分组，它实际上是topic下的一个存储目录，目录下的消息存储方式决定了partition是一个有序的队列。kafka保证同一partition的消息是有序的，但不保证partition之前的顺序。同一topic的不同分区会分配再不同的broker上，partition的命名规则为topic名+分区序号。分区是kafka水平拓展的基础，我们可以通过增加服务器并再其上分配partion的方式来增加kafka的并行处理能力。</p>
</li>
<li><p>segment partition由多个segment组成，物理上segment是partition目录上的真是存储消息的文件。segment file由两部分组成：index file和data file，segement文件命名规则是partition下的第一个segment从0开始，后续的每个offset是前一个segment的最后一条消息的offerset值。数值为64位long大小，前面用0填充。</p>
</li>
</ul>
<p><img src="http://osjt45oaj.bkt.clouddn.com/kafka-1.png" alt=""><br>上图是segment的index文件与data文件的映射关系，当要查找partition中offset为x值的消息时，先通过二分查找定位到x所在segment的index文件，然后在通过index中的稀疏索引定位到消息在long中偏移量。具体可参考<a href="https://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kafka文件存储机制那些事
</a></p>
<p>kafka采用顺序磁盘I/O,所以指向最新的segment追加消息，当超出segment大小限制时，kafka会创建新的segement。正是由于kafka基于磁盘的消息存储，所以无论消费者是否已经拉取消息，kafka都会一直保留这些消息，但是为了节省磁盘空间，kafka必须实现周期性地删除旧的消息，kafka实现了两种保留策略，一是根据消息保留的时间，当消息在kafka中保留超过指定时间，可以被删除，另一种是指定topic中消息的数据量，超过一定量删除旧的消息，kafka会启动一个后台线程，定时检查topic中的消息是否可以删除，当达到条件时，直接删除顺序最前的segment就可以了。</p>
<ul>
<li><p>副本</p>
<p>kafka中partition可以有多个副本，是对消息的一本备份策略。每个分区至少有一个副本，当分区中只有一个副本时，就只有leader副本。每个分区的副本集合都会选举出一个副本作为leader,选举策略采用多数同意的方式，所以kafka的副本允许N-1的不存活。</p>
</li>
<li><p>ISR集合</p>
</li>
</ul>
<p>ISR(In-Sync Replica)集合表示目前可用的分区副本集。ISR集合中的副本必须保证两个条件：1.维持与zk的连接。2.最后一条消息的offset与leader的差值不超过指定阀值。有两个参数可以决定是否将ISR移除ISR集合：replica.lag.max.messages和replica.lag.time.max，前者表明副本offset落后leader offset的最大消息数，后者表示follower向leader发送请求的最大时间间隔。如果再一定的周期内follower不能追赶上leader,可能是由于I/O问题导致follower追加复制消息慢于leader拉取速度，这种属于慢副本。还有一种是卡住副本，由于GC或者副本死亡导致follower停止发送复制请求。</p>
<ul>
<li>HW&amp;LEO</li>
</ul>
<p>HW(high watermark)表示消费者拉取消息的高水位，它标记了一个特殊的offset值，意思就是消费者只能拉取HW之前的消息，HW之后的消息对消费者不可见。当ISR集合中全部的follower都拉取的HW指定消息进行同步后，leader会递增HW的值。</p>
<p>LEO(log end offset)是当前副本的最后一条消息的offset。HW和LEO这两个值都是和ISR集合相关的，引用HW是为了避免消息提交后，follower还未拉取消息，leader跑的过快，此时leader宕机导致的消息丢失问题。但ISR集合有效避免了消息同步复制带来的延时问题，当Followe副本延迟过高时，leader副本被踢出ISR集合，消息已然可以快速提交，当leader宕机时，会选举ISR集合中的follower作为新的leader,这新的leader包含hw之前的所有消息，这样既保证的消息不会丢失，也解决的消息同步带来的影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/19/kafka-one/" data-id="cje5obazf000eus2mgj646vwf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dynamic-proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/24/dynamic-proxy/" class="article-date">
  <time datetime="2017-09-24T03:07:38.000Z" itemprop="datePublished">2017-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/dynamic-proxy/">ASM初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>   随着aop技术的兴起，动态代理得到越来越广泛的应用。下面我们就来聊一聊在java中实现动态代理都有哪些方式，关于动态代理的介绍可参考博主之前的一篇文章，其中介绍了一下JDK动态代理的使用方法和原理简介<br><a href="http://www.clouder.top/2017/04/12/JDK-Dynamic-Proxy/" target="_blank" rel="external">JDK动态代理</a><br>。动态代理说白了就是再程序运行期间，动态的改变一个类的行为或者生成一个新的类。我们知道JVM通过字节码的二进制信息加载类的，类的初始化过程第一步就是把class文件里所代表的静态存储结构转化为方法区的运行数据结构，当然加载过程只会进行一次。所以要动态的改变类的行为就需要我们遵循JVM的规范生成新的字节码。<br><img src="http://osjt45oaj.bkt.clouddn.com/dynamicproxy.png" alt=""><br>上图是网上别人画的一个动态生成类的原理图，很清晰的展示了动态代理的基本原理，在运行期生成新的字节码，然后类加载器完成类的初始化过程得到新类。</p>
<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><p>下面我们来看一下如何在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。其实JDK提供了sun.misc.ProxyGenerator.generateProxyClass(String proxyName,class[] interfaces)底层方法来产生动态代理的字节码。<br>除此之外，但这种实现现在已开源的解决方案有ASM和javaassist。</p>
<p>ASM是一个Java字节码操控框架。ASM从class文件载入后，可以分析类信息，改变类的行为，也能够根据要求生成新类。它能够以二进制形式修改已有类或者动态生成类。ASM可以直接产生二进制class文件，也可以在类被加载入Java虚拟机之前动态改变类行为。</p>
<p>ASM在创建class字节码的过程中，操纵是底层JVM的汇编指令，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。对于这些内容可以参考《JAVA虚拟机规范》。asm字节码增强技术主要是用来反射的时候提升性能的，如果单纯用jdk的反射调用，性能是非常低下的，而使用字节码增强技术后反射调用的时间已经基本可以与直接调用相当了。asm是一个轻量级的字节码框架，他的jar包仅几十k，它的核心类有以下几个：</p>
<ul>
<li>ClassReader:根据字节码的规则解析编译过的class文件。</li>
<li>ClassWriter:对已解析的类进行增强，比如说修改类名、属性以及方法，以及生成新的类的字节码文件。</li>
<li>ClassAdapter:该类也实现了ClassVisitor接口，它将对它的方法调用委托给另一个ClassVisitor对象。</li>
</ul>
<p>我们可以先来看一下字节码的结构，这样可以很容易的理解ASM到底做了什么以及它为什么要这样设计。<br><img src="http://osjt45oaj.bkt.clouddn.com/asm02.png" alt=""><br>关于上图中各部分的含义看名字也能一目了然，这里重点说一下常量池部分，一个类的常量池占了它本身的绝大部分空间，常量池里除了包括字符串常量和数值常量，还包含指向字段和方法的引用。</p>
<p>编译后的字节码文件与源文件的不同的在于：<br>编译后的 java 类仅仅只 述一个类信息，但是一个 java 源文件可以包含几个java 类 ；<br>编译后的 java 类不包含注释；<br>编译后的 java 类不包含 package 和 import段，因此，在编译后的类中，所有的类型名称都必须使用全路径；<br>编译后的 java 类包含一个常量池段 。（asm隐藏了与常量池相关的细节）</p>
<p>字节码操作工具有：</p>
<ul>
<li>BCEL：Byte Code Engineering Library (BCEL)，这是Apache Software Foundation 的Jakarta 项目的一部分。BCEL是 Java classworking 最广泛使用的一种框架,它可以让您深入 JVM 汇编语言进行类操作的细节。BCEL与Javassist 有不同的处理字节码方法，BCEL在实际的JVM 指令层次上进行操作(BCEL拥有丰富的JVM 指令级支持)而Javassist 所强调的源代码级别的工作。</li>
<li>JBET：通过JBET(Java Binary Enhancement Tool )的API可对Class文件进行分解，重新组合，或被编辑。JBET也可以创建新的Class文件。JBET用一种结构化的方式来展现Javabinary (.class)文件的内容，并且可以很容易的进行修改。</li>
<li>javaassist：直接使用java编码，不需要了解jvm指令，其工作方式与 JVM 类装载器非常相似。</li>
</ul>
<p>ASM的优势在于：</p>
<ul>
<li>ASM 具有简单、设计良好的 API，这些 API 易于使用；</li>
<li>ASM 有非常良好的开发文档，以及可以帮助简化开发的 Eclipse 插件；</li>
<li>ASM 支持 Java 6(ASM3)、Java7(ASM4)、Java(ASM5)；</li>
<li>ASM 很小、很快、很健壮；</li>
<li>ASM 有很大的用户群，可以帮助新手解决开发过程中遇到的问题；</li>
<li>ASM 的开源许可可以让你几乎以任何方式使用它；</li>
</ul>
<p>不说废话了，下面来看一下ASM的核心接口，ClassVisitor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public interface ClassVisitor &#123;</div><div class="line">    void visit(int var1, int var2, String var3, String var4, String var5, String[] var6);</div><div class="line"> </div><div class="line">    void visitSource(String var1, String var2);</div><div class="line"> </div><div class="line">    void visitOuterClass(String var1, String var2, String var3);</div><div class="line"> </div><div class="line">    AnnotationVisitor visitAnnotation(String var1, boolean var2);</div><div class="line"> </div><div class="line">    void visitAttribute(Attribute var1);</div><div class="line"> </div><div class="line">    void visitInnerClass(String var1, String var2, String var3, int var4);</div><div class="line"> </div><div class="line">    FieldVisitor visitField(int var1, String var2, String var3, String var4, Object var5);</div><div class="line"> </div><div class="line">    MethodVisitor visitMethod(int var1, String var2, String var3, String var4, String[] var5);</div><div class="line"> </div><div class="line">    void visitEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ClassVisitor把类的字节码所包含的信息组织成一个树状结构，在访问类结构中简单的段时， 是通过调用一个独立的方法来实现的，该方法的参数就是该段相关的内容，该方法的返回值 为 void。对长度任意并且较复杂的段进行访问时，是通过一个初始化方法返回一个辅助的 visitor 接口来实现，例如 visitAnnotation，visitField 以及 visitMethod，它们都返回与之对应 的接口 AnnotationVisitor，FieldVisitor 以及 MethodVisitor。</p>
<p>对 ClassVisitor 接口中方法的调用必须遵循下面文档定义的顺序 ：<br>visit visitSource? visitOuterClass? ( visitAnnotation | visitAttribute )*( visitInnerClass | visitField | visitMethod )<em>  visitEnd (?表示至多1次，\</em>表示任意次数)<br>这其实很好理解，类的字节码是按照一定规则排列的。同样，对MethodVisitor接口中方法的调用必须遵循下面文档定义的顺序：<br>( visitTryCatchBlock | visitLabel | visitFrame | visitXxxInsn | visitLocalVariable | visitLineNumber )*<br>visitMaxs )?<br>visitEnd</p>
<p>解析一个已存在的类仅需要ClassReader这个组件，它对字节码的每一段解析都可以看成产生一个事件。ClassWriter实现了ClassVisitor接口，实现了ClassVisitor接口中每个visitxx方法，当捕获对应事件时，可以将字节码写到指定位置，ASM是可以看成一个观察者模式的实现，ClassReader可以接收一个ClassWriter作为它的观察者，当ClassReader解析字节码的每一段产生一个事件时，会触发ClassWriter中对应的visitxx方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">byte[] b1 = ...;ClassWriter cw = new ClassWriter();</div><div class="line">ClassReader cr = new ClassReader(b1);cr.accept(cw, 0);byte[] b2 = cw.toByteArray();</div></pre></td></tr></table></figure>
<p>上面的代码复制b1创建一个新的类b2,实际上是将一个字节数组复制到另一个字节数组。这个过程可能看起来意义不大，但是如果我们加上一个新的组件ClassAdapter那就会变得很有趣。ClassAdapter也是实现了ClassVisitor接口，它相当于一个事件过滤器，通过自定义visitxx方法，同样再获取ClassReader产生的事件时执行相应的visitxx方法，达到按照开发者意愿修改字节码的目的，最后将事件传给ClassWriter将修改后的字节码落地。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class ChangeVersionAdapter extends ClassAdapter &#123;public ChangeVersionAdapter(ClassVisitor cv) &#123; super(cv);&#125;@Overridepublic void visit(int version, int access, String name,String signature, String superName, String[] interfaces) &#123;cv.visit(V1_5, access, name, signature, superName, interfaces); &#125;&#125;</div></pre></td></tr></table></figure>
<p>上面代码中自定义了一个ClassAdapter,它只重写了visit方法，在visit方法中修改了类的版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte[] b1 = ...ClassReader cr = new ClassReader(b1);ClassWriter cw = new ClassWriter(cr, 0);ChangeVersionAdapter ca = new ChangeVersionAdapter(cw); cr.accept(ca, 0);byte[] b2 = cw.toByteArray();</div></pre></td></tr></table></figure>
<p>上面代码中ca只在字节码的version段触发了一个修改类版本号的动作，剩余部分都直接转发给ClassWriter。</p>
<p>ClassAdapter是事件的转发者，转化过程形成一条classReader-classAdapter-classWriter的转换链，但一个转换链条没必要是线性的，更复杂的情况是你可以编写一个 ClassVisitor，然后同时转发所有的方法调用给多个 ClassVisitor。<br><img src="http://osjt45oaj.bkt.clouddn.com/asm3.png" alt=""><br>这样需要开发者在整体性能和低耦合之间做一个权衡。上面就是asm的主要组件及大致原理，它实际上相当于做了一个字节码层面的aop,基于观察者模式的事件触发，原理很简单，掌握了它的规则，使用起来也并不难。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/24/dynamic-proxy/" data-id="cje5obaz20005us2m5qjk13u2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mybatis-cache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/27/mybatis-cache/" class="article-date">
  <time datetime="2017-08-27T07:10:22.000Z" itemprop="datePublished">2017-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/mybatis-cache/">mybatis缓存体系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Mybatis基本概念"><a href="#Mybatis基本概念" class="headerlink" title="Mybatis基本概念"></a>Mybatis基本概念</h1><p>每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话。我们先来看下sqlSession的创建过程:<br><img src="http://osjt45oaj.bkt.clouddn.com/mybatis1.png" alt=""><br>关于mybatis的初始化过程，这里不做探讨，只看下mybatis对数据库的会话过程中涉及的核心对象。</p>
<ul>
<li>Configuration     mybatis配置信息（mybatis初始化过程实际就是创建Configuration对象的过程）</li>
<li>SqlSession        数据库会话</li>
<li>SqlSessionFactory 数据库会话创建工厂</li>
<li>Excutor          执行器，调度核心</li>
<li>StatementHandler     封装了JDBC Statement操作，如设置参数、将Statement结果集转换成List集合。</li>
<li>MappedStatement   一个<select|update|delete|insert>节点的抽象。</select|update|delete|insert></li>
<li>BoundSql  动态生成的SQL语句以及相应的参数信息。</li>
</ul>
<h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>Mybatis的缓存体系由一级缓存和二级缓存构成，我们先来分析下一级缓存。缓存的意义是显而易见的，可以提高响应速度和降低资源消耗，Mybatis一级缓存的设计初衷也是基于这点。在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库,而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。 为了解决这一问题，减少资源的浪费，MyBatis在SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。<br><img src="http://osjt45oaj.bkt.clouddn.com/QQ20161023-0.jpg" alt=""><br>mybatis执行数据curd操作是通过sqlSession完成。以查询为例，sqlSession的select操作最终交给执行器Excutor来完成，下面看下Excutor的query方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</div><div class="line">   //得到绑定sql</div><div class="line">   BoundSql boundSql = ms.getBoundSql(parameter);</div><div class="line">   //创建缓存Key</div><div class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</div><div class="line">   //查询</div><div class="line">   return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> @Override</div><div class="line"> public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</div><div class="line">   ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</div><div class="line">   //如果已经关闭，报错</div><div class="line">   if (closed) &#123;</div><div class="line">     throw new ExecutorException(&quot;Executor was closed.&quot;);</div><div class="line">   &#125;</div><div class="line">   //先清局部缓存，再查询。但仅查询堆栈为0，才清。为了处理递归调用</div><div class="line">   if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</div><div class="line">     clearLocalCache();</div><div class="line">   &#125;</div><div class="line">   List&lt;E&gt; list;</div><div class="line">   try &#123;</div><div class="line">     //加一,这样递归调用到上面的时候就不会再清局部缓存了</div><div class="line">     queryStack++;</div><div class="line">     //先根据cachekey从localCache去查</div><div class="line">     list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</div><div class="line">     if (list != null) &#123;</div><div class="line">       //若查到localCache缓存，处理localOutputParameterCache</div><div class="line">       handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</div><div class="line">     &#125; else &#123;</div><div class="line">       //从数据库查</div><div class="line">       list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</div><div class="line">     &#125;</div><div class="line">   &#125; finally &#123;</div><div class="line">     //清空堆栈</div><div class="line">     queryStack--;</div><div class="line">   &#125;</div><div class="line">   if (queryStack == 0) &#123;</div><div class="line">     //延迟加载队列中所有元素</div><div class="line">     for (DeferredLoad deferredLoad : deferredLoads) &#123;</div><div class="line">       deferredLoad.load();</div><div class="line">     &#125;</div><div class="line">     // issue #601</div><div class="line">     //清空延迟加载队列</div><div class="line">     deferredLoads.clear();</div><div class="line">     if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</div><div class="line">       //如果是STATEMENT，清本地缓存</div><div class="line">       clearLocalCache();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   return list;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">//从数据库查</div><div class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</div><div class="line">  List&lt;E&gt; list;</div><div class="line">  //先向缓存中放入占位符</div><div class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</div><div class="line">  try &#123;</div><div class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</div><div class="line">  &#125; finally &#123;</div><div class="line">    //最后删除占位符</div><div class="line">    localCache.removeObject(key);</div><div class="line">  &#125;</div><div class="line">  //加入缓存</div><div class="line">  localCache.putObject(key, list);</div><div class="line">  //如果是存储过程，参数也加入缓存</div><div class="line">  if (ms.getStatementType() == StatementType.CALLABLE) &#123;</div><div class="line">    localOutputParameterCache.putObject(key, parameter);</div><div class="line">  &#125;</div><div class="line">  return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现query方法中首先会通过createCacheKey方法创建缓存key，得到的结果就是一级缓存中的键值。Mybatis对于其缓存key的生成规则： mappedStementId + offset + limit + SQL + queryParams + environment生成hashCode。，CacheKey会根据这些条件来区分每一个CacheKey。cacheKey中会保存key的hashCode,参数个数以及将参数保存在updateList中。可以发现，mybatis根据<select>标签所在的Mapper的Namespace+</select><select>标签的id属性、处理分页类RowBounds的limit和offset、sql语句、sql参数这几个条件来判断两次查询是否相同。</select></p>
<p>通过上面的代码我们可以发现一级缓存就是执行器BaseExcutor的一个成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected PerpetualCache localCache;</div></pre></td></tr></table></figure>
<p>进入PerpetualCache可以揭开一级缓存的真面目，实际上就是一个本地缓存hashMap.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class PerpetualCache implements Cache &#123;</div><div class="line"></div><div class="line">  private String id;</div><div class="line"></div><div class="line">  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>至此我们可以发现Mybatis一级缓存以单纯的HashMap做缓存，没有容量控制，是一个粗粒度的缓存，没有更新缓存和缓存过期的概念。只适用于一次SqlSession，而一次SqlSession中通常来说并不会有大量的查询操作，而且只要执行update操作（update、insert、delete），都会将这个SqlSession对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响JVM内存空间的问题；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//SqlSession.update/insert/delete会调用此方法</div><div class="line">@Override</div><div class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</div><div class="line">  ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</div><div class="line">  if (closed) &#123;</div><div class="line">    throw new ExecutorException(&quot;Executor was closed.&quot;);</div><div class="line">  &#125;</div><div class="line">  //update操作会清除所有缓存</div><div class="line">  clearLocalCache();</div><div class="line">  return doUpdate(ms, parameter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line">@Override</div><div class="line">  public void clearLocalCache() &#123;</div><div class="line">    if (!closed) &#123;</div><div class="line">      localCache.clear();</div><div class="line">      localOutputParameterCache.clear();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>总结下一级缓存存储过程：</p>
<ol>
<li>对于某个Select Statement，根据该Statement生成cacheKey。</li>
<li>判断在Local Cache中,该key是否用对应的数据存在。</li>
<li>如果命中，则跳过查询数据库，继续往下走。</li>
<li>如果没命中,去数据库中查询数据，得到查询结果,将cacheKey和查询到的结果作为key和value，放入Local Cache中,将查询结果返回。</li>
<li>判断缓存级别是否为STATEMENT级别，如果是的话，清空本地缓存。</li>
</ol>
<p>Mybatis一级缓存的生命周期和SqlSession一致。本质就是一个hashMap,<br>而且不同sqlSession的更新数据会引发脏数据问题，所以建议不使用一级缓存。<br>三种方式不走一级缓存：</p>
<ol>
<li><p>一级缓存的默认级别设定为Statement，即不使用一级缓存。\<setting name="localCacheScope" value="STATEMENT"></setting></p>
</li>
<li><p>\<select>标签中的flushCache属性设置为true</select></p>
</li>
<li><p>Mybatis的拦截器</p>
</li>
</ol>
<h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>在mybatis中，缓存的功能由根接口Cache定义，整个体系采用装饰器模式。数据存储和缓存的基本功能由perpetualCache实现，然后通过一系列的装饰器对perpetualCache进行缓存策略的方便控制。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/mybatis2.png" alt=""></p>
<ol>
<li>FifoCache：先进先出算法，缓存回收策略</li>
<li>LoggingCache：输出缓存命中的日志信息</li>
<li>LruCache：最近最少使用算法，缓存回收策略</li>
<li>ScheduledCache：调度缓存，负责定时清空缓存</li>
<li>SerializedCache：缓存序列化和反序列化存储</li>
<li>SoftCache：基于软引用实现的缓存管理策略</li>
<li>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</li>
<li>WeakCache：基于弱引用实现的缓存管理策略</li>
<li>特殊的装饰器TransactionalCache：事务性的缓存</li>
</ol>
<p>二级缓存默认关闭。若开启先在Configuration下增加  \<setting name="cacheEnabled" value="true">，然后在mapper映射文件增加<cache>或<cache-ref>节点  注解方式增加@CacheNamespace或者@CacheNamespaceRef()。</cache-ref></cache></setting></p>
<p>和cache体系差不多，mybatis执行器也是通过委托的方式实现执行器的灵活控制<br> <img src="http://osjt45oaj.bkt.clouddn.com/mybatis3.png" alt=""><br> 若二级缓存开启，则mybatis默认的执行器为CachingExecutor。<br> 流程为： 从二级缓存中进行查询 -&gt; [如果缓存中没有，委托给 BaseExecutor] -&gt; 进入一级缓存中查询 -&gt; [如果也没有] -&gt; 则执行 JDBC 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</div><div class="line">    throws SQLException &#123;</div><div class="line">  Cache cache = ms.getCache();</div><div class="line">  //只有通过&lt;cache/&gt;,&lt;cache-ref/&gt;或@CacheNamespace,@CacheNamespaceRef标记使用缓存的Mapper.xml或Mapper接口才会有二级缓存。</div><div class="line">  if (cache != null) &#123;</div><div class="line">    flushCacheIfRequired(ms);</div><div class="line">    if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</div><div class="line">      ensureNoOutParams(ms, parameterObject, boundSql);</div><div class="line">      @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</div><div class="line">      if (list == null) &#123;</div><div class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">        tcm.putObject(cache, key, list); // </div><div class="line">      &#125;</div><div class="line">      return list;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的tcm.putObject方法执行完之后缓存并没有真正的生效，这里只是记录了这次查询将要产生缓存变更，这时候相同的sql查询缓存是不会生效的。下面看下TransactionalCacheManager#putObject（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void putObject(Cache cache, CacheKey key, Object value) &#123;</div><div class="line">  getTransactionalCache(cache).putObject(key, value);</div><div class="line">&#125;</div><div class="line">private TransactionalCache getTransactionalCache(Cache cache) &#123;</div><div class="line">  TransactionalCache txCache = transactionalCaches.get(cache); </div><div class="line">  if (txCache == null) &#123;</div><div class="line">    txCache = new TransactionalCache(cache);</div><div class="line">    transactionalCaches.put(cache, txCache);</div><div class="line">  &#125;</div><div class="line">  return txCache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际只有执行了sqlSession的commit方法之后，缓存的变更会真正的被刷新到缓存中去，开始真正的发挥作用。因为sqlSession的commit会调到上面TransactionalCache的commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public void commit() &#123;</div><div class="line">  if (clearOnCommit) &#123;</div><div class="line">    delegate.clear();</div><div class="line">  &#125;</div><div class="line">  flushPendingEntries();</div><div class="line">  reset();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void rollback() &#123;</div><div class="line">  unlockMissedEntries();</div><div class="line">  reset();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void reset() &#123;</div><div class="line">  clearOnCommit = false;</div><div class="line">  entriesToAddOnCommit.clear();</div><div class="line">  entriesMissedInCache.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void flushPendingEntries() &#123;</div><div class="line">  for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</div><div class="line">    delegate.putObject(entry.getKey(), entry.getValue());</div><div class="line">  &#125;</div><div class="line">  for (Object entry : entriesMissedInCache) &#123;</div><div class="line">    if (!entriesToAddOnCommit.containsKey(entry)) &#123;</div><div class="line">      delegate.putObject(entry, null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，写操作也不是马上会清除缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public int update(MappedStatement ms, Object parameterObject) throws SQLException &#123;</div><div class="line">//默认刷新缓存</div><div class="line">   flushCacheIfRequired(ms);</div><div class="line">   return delegate.update(ms, parameterObject);</div><div class="line"> &#125;</div><div class="line">private void flushCacheIfRequired(MappedStatement ms) &#123;</div><div class="line">  Cache cache = ms.getCache();</div><div class="line">  if (cache != null &amp;&amp; ms.isFlushCacheRequired()) &#123;      </div><div class="line">    tcm.clear(cache);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结</p>
<ol>
<li>二级缓存是以namespace为单位，不同namespace下互不影响。</li>
<li>写操作会清空所在namespace下所有缓存。</li>
<li>一个namespace下操作多张表会引起脏数据问题。</li>
<li>正是由于Mybatis cache体制这种灵活的委托机制，我们可以借助外部缓存来自定义Mybatis的二级缓存。</li>
</ol>
<p>上面就是Mybatis的缓存体系，设计上很简单，也存在不少的坑，所以我们使用的时候还是自己实现或者借助外部缓存，让Mybatis只完成它的本职工作就好！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/27/mybatis-cache/" data-id="cje5obayu0001us2mt884iz6i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/23/redis-list/" class="article-date">
  <time datetime="2017-07-23T02:26:06.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/23/redis-list/">redis消息队列实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大家都知道redis相较同类产品memcache而言有着丰富的数据类型,这里我们稍微说一下redis中的list数据类型，list的容量是2^32-1个元素，它存储的是链表结构，链表的属性是不管整个链表有多大，它的头尾操作是非常快的，这就符合一个消息队列的特性，简单意义上的消息队列就是生产者从对头插数据，消费者从队尾取数据，所以我们可以用redis中的list来实现一个mq。但是要使用mq，用市面上成熟的消息中间件产品岂不是更好？如rabbitmq、kafka等，当然，如rabbitmq、kafka等，当然如果要保证高可用高性能高吞吐量的消息队列，自然是要考虑使用此类成熟的中间件，这也不在本文描述范畴。但redis作为消息队列的好处是可以对消息的收发做到一个灵活的控制，添加一些自定义的行为，比如给消息定义优先级，所以在一定的业务场景下，将redis作为消息队列不失为一种好的选择。那么到底要如何实现呢。下面我们就演示一下在spring中如何整合redis消息队列。</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class RedisMq &#123;</div><div class="line">    @Resource</div><div class="line">    protected RedisTemplate jedisTemplate;</div><div class="line"></div><div class="line">    public void sendToRedis(final String msg) &#123;</div><div class="line">        String listName = &quot;xxx&quot;;</div><div class="line">        jedisTemplate.opsForList().rightPush(listName, mag);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生产者的代码很简单，就是往redis的指定list的一端push一条消息。下面就看一下消费者一端如何想spring整合其他mq那样监听队列。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>初始化队列类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class InitializeQueue implements InitializingBean, DisposableBean &#123;</div><div class="line">    private QueueListener listener;</div><div class="line">    private RedisTemplate redisTemplate;</div><div class="line">    private static List&lt;RedisQueue&gt; listQ = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建启动redis连接并监听</div><div class="line">     */</div><div class="line">    public void createQueue() &#123;</div><div class="line">        //这里先获取所有要监听的redis list名</div><div class="line">        List keys = xxx;</div><div class="line">        if (keys != null) &#123;</div><div class="line">            for (String key : keys) &#123;</div><div class="line">                RedisQueue queue = new RedisQueue();</div><div class="line">                queue.setListener(listener);</div><div class="line">                queue.setRedisTemplate(redisTemplate);</div><div class="line">                queue.setKey(app.getAppName());</div><div class="line">                listQ.add(queue);</div><div class="line">                try &#123;</div><div class="line">                    queue.start();</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    log.error(&quot;启动redis异常!&#123;&#125;&quot;, e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public QueueListener getListener() &#123;</div><div class="line">        return listener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setListener(QueueListener listener) &#123;</div><div class="line">        this.listener = listener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RedisTemplate getRedisTemplate() &#123;</div><div class="line">        return redisTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setRedisTemplate(RedisTemplate redisTemplate) &#123;</div><div class="line">        this.redisTemplate = redisTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 销毁redis连接</div><div class="line">     *</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void destroy() throws Exception &#123;</div><div class="line">        for (RedisQueue queue : listQ) &#123;</div><div class="line">            queue.destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void afterPropertiesSet() throws Exception &#123;</div><div class="line">        //创建队列</div><div class="line">        createQueue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>队列监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public interface QueueListener&lt;T&gt; &#123;</div><div class="line">    public void onMessage(T message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class RedisQueueListener implements QueueListener&lt;String&gt; &#123;</div><div class="line">    private ExecutorService threadpool = Executors.newFixedThreadPool(10);</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onMessage(String value) &#123;</div><div class="line">        threadpool.execute(new MessageRunnable(value));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class MessageRunnable implements Runnable &#123;</div><div class="line">        private String msg</div><div class="line">        public MessageRunnable(String msg) &#123;</div><div class="line">            this.msg = msg;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            log.info(&quot;处理消息!&quot;);</div><div class="line">            //消息处理业务代码</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消息队列实例，当创建一个RedisQueue实例就会绑定redis中一个list，并一直从list的尾部取出数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line">public class RedisQueue&lt;T&gt; &#123;</div><div class="line">    private RedisTemplate redisTemplate;</div><div class="line">    private String key;</div><div class="line">    private int cap = Short.MAX_VALUE;//最大阻塞的容量，超过容量将会导致清空旧数据</div><div class="line">    private byte[] rawKey;</div><div class="line">    private RedisConnectionFactory factory;</div><div class="line">    private RedisConnection connection;//for blocking</div><div class="line">    private BoundListOperations&lt;String, T&gt; listOperations;//noblocking</div><div class="line">    private Lock lock = new ReentrantLock();//基于底层IO阻塞考虑</div><div class="line">    private QueueListener listener;//异步回调</div><div class="line">    private Thread listenerThread;</div><div class="line">    private boolean isClosed = false;</div><div class="line">    //组塞10分钟</div><div class="line">    private int  timeout = 600;</div><div class="line">    //休息时间</div><div class="line">    private int sleepTime = 1000;</div><div class="line">    //获取为null 次数</div><div class="line">    private int failCount = 30;</div><div class="line">    public void setRedisTemplate(RedisTemplate redisTemplate) &#123;</div><div class="line">        this.redisTemplate = redisTemplate;</div><div class="line">    &#125;</div><div class="line">    public void setListener(QueueListener listener) &#123;</div><div class="line">        this.listener = listener;</div><div class="line">    &#125;</div><div class="line">    public void setKey(String key) &#123;</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 启动监听</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    public void start() throws Exception &#123;</div><div class="line">        factory = redisTemplate.getConnectionFactory();</div><div class="line">        connection = RedisConnectionUtils.getConnection(factory);</div><div class="line">        rawKey = redisTemplate.getKeySerializer().serialize(key);</div><div class="line">        listOperations = redisTemplate.boundListOps(key);</div><div class="line">        if(listener != null)&#123;</div><div class="line">            listenerThread = new ListenerThread();</div><div class="line">            listenerThread.setDaemon(false);</div><div class="line">            listenerThread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * blocking</div><div class="line">     * 队列尾部取数据</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public T takeFromTail(int timeout) throws InterruptedException&#123;</div><div class="line">        lock.lockInterruptibly();</div><div class="line">        try&#123;</div><div class="line">            List&lt;byte[]&gt; results = connection.bRPop(timeout, rawKey);</div><div class="line">            if(CollectionUtils.isEmpty(results))&#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            return (T)redisTemplate.getValueSerializer().deserialize(results.get(1));</div><div class="line">        &#125;finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T takeFromTail() throws InterruptedException&#123;</div><div class="line">        return takeFromTail(timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 从队列的头，插入</div><div class="line">     */</div><div class="line">    public void pushFromHead(T value)&#123;</div><div class="line">        listOperations.leftPush(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pushFromTail(T value)&#123;</div><div class="line">        listOperations.rightPush(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 队尾取出</div><div class="line">     */</div><div class="line">    public T removeFromHead()&#123;</div><div class="line">        return listOperations.leftPop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T removeFromTail()&#123;</div><div class="line">        return listOperations.rightPop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 队尾取出增加超时时间</div><div class="line">     */</div><div class="line">    public T takeFromHead(int timeout) throws InterruptedException&#123;</div><div class="line">        lock.lockInterruptibly();</div><div class="line">        try&#123;</div><div class="line">            List&lt;byte[]&gt; results = connection.bLPop(timeout, rawKey);</div><div class="line">            if(CollectionUtils.isEmpty(results))&#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            return (T)redisTemplate.getValueSerializer().deserialize(results.get(1));</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            System.out.println(e);</div><div class="line">            log.error(&quot;get the value fail!&quot;,e);</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T takeFromHead() throws InterruptedException&#123;</div><div class="line">        return takeFromHead(timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void destroy() throws Exception &#123;</div><div class="line">        if(isClosed)&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        shutdown();</div><div class="line">        RedisConnectionUtils.releaseConnection(connection, factory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void shutdown()&#123;</div><div class="line">        try&#123;</div><div class="line">            listenerThread.interrupt();</div><div class="line">        &#125;catch(Exception e)&#123;</div><div class="line">            //注销失败</div><div class="line">            log.error(&quot;注销失败!&quot;,e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class ListenerThread extends Thread &#123;</div><div class="line">        int count = 0;</div><div class="line">        @Override</div><div class="line">        public void run()&#123;</div><div class="line">            try&#123;</div><div class="line">                while(true)&#123;</div><div class="line">                    //超过一定次数 休眠一段时间再去获取信息</div><div class="line">                    if(count &gt; failCount)&#123;</div><div class="line">                        Thread.sleep(sleepTime);</div><div class="line">                        count = 0;</div><div class="line">                    &#125;</div><div class="line">                    log.info(&quot;开始消费!&quot;);</div><div class="line">                    T value = takeFromHead();</div><div class="line">                    log.info((String)value);</div><div class="line">                    //逐个执行</div><div class="line">                    if(value != null)&#123;</div><div class="line">                        try&#123;</div><div class="line">                            listener.onMessage(value);</div><div class="line">                        &#125;catch(Exception e)&#123;</div><div class="line">                            log.error(&quot;处理消息错误!&quot;,e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;else&#123;</div><div class="line">                        count ++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                //处理消息错误</div><div class="line">                log.error(&quot;线程获取消息错误!&quot;,e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        if (obj instanceof RedisQueue) &#123;</div><div class="line">            RedisQueue queue = (RedisQueue) obj;</div><div class="line">            return queue.key.equals(this.key);</div><div class="line">        &#125;</div><div class="line">        return super.equals(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后在Spring上下文中将注入，大功告成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;initializeQueue&quot; class=&quot;com.clouder.redis.InitializeQueue&quot;&gt;</div><div class="line">        &lt;property name=&quot;listener&quot; ref=&quot;redisQueueListener&quot;&gt;&lt;/property&gt;</div><div class="line">        &lt;property name=&quot;redisTemplate&quot; ref=&quot;redisTemplate&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>上述就是spring中整合redis list实现消息队列的过程。总结一下，创建一个队列初始化类注入spring上下文中随spring启动创建实例，初始化类中根据要监听的队列名创建队列实例，RedisQueue实例中启动后台线程从redis list中取出消息调用redis监听器的onMessage方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/23/redis-list/" data-id="cje5obazo000kus2mugd8r9nd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RateLimiter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/14/RateLimiter/" class="article-date">
  <time datetime="2017-07-14T10:24:32.000Z" itemprop="datePublished">2017-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/14/RateLimiter/">接口限流之RateLimiter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>   对于高并发的系统而言，缓存、限流和降级是保证服务可用的三大利器。由于缓存的性能越来越高，对于系统能抗住高并发流量的作用自然不必多说；熔断和降级是保证服务可用的最后一道屏障，它是在下游服务故障或者系统负荷过高时不得不做的处理，通过一些mock的处理让服务暂时看起来可用，待高峰过后重新恢复。但在有些场景下，可以用来控制服务的请求速率，如双十一和12306的限流。</p>
<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p>  常见的限流算法有漏桶算法和令牌桶算法。<br>  <img src="http://osjt45oaj.bkt.clouddn.com/leaky_bucket.GIF" alt=""><br>上图可以直观的表现出漏桶算法的思想，请求可以看成水流，以一定速率的出水进入漏桶中，然后漏桶以一定的速率出水，当水流入速度过大会溢出，漏桶算法会强行限制数据的传输速率。突发流量会被限制成一个稳定的流量，如果漏桶溢出，那么数据包或者请求就会被丢弃。漏桶算法的缺陷是不能有效利用系统资源，即使不存在资源冲突，漏桶仍然已恒定的速率流出，故不能应对突发特性的流量。<br><img src="http://osjt45oaj.bkt.clouddn.com/token_bucket.JPG" alt=""><br>令牌桶算法的原理是系统已恒定的速率往桶内放入令牌，请求过来需要先从桶内取得令牌然后请求被处理，如果没取到则拒绝服务。假设限制速率2r/s即一秒2个往桶中放入令牌，桶的容量为n,当一个a个字节的数据包到达时，将从桶中删除a个令牌，如果当前桶的令牌数小于a，则本次请求被限流；令牌桶的一个优点在于可以按需改变放入令牌的速率来应对突发性的流量。</p>
<h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><p>RateLimiter出自大名鼎鼎的guava包，它是令牌桶算法的一种实现。RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率。与Semaphore 相比，Semaphore 限制了并发访问的数量而不是使用速率。<br>考虑下面的场景：我们需要执行一堆任务，但我们希望任务的提交速率限制在最多1s一个。我们利用RateLimiter来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">final RateLimiter rateLimiter = RateLimiter.create(1);</div><div class="line">Executor threadPool = Excutors.newFixedThreadPool(10);    </div><div class="line"> void submitTasks(List tasks) &#123;</div><div class="line">        for (Runnable task : tasks) &#123;</div><div class="line">            rateLimiter.acquire(); // 需要等待拿到令牌</div><div class="line">            executor.execute(task);</div><div class="line">        &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>下面再来考虑一个抢购的场景对接口进行限流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">public class ActivityController &#123;</div><div class="line">    @Resource</div><div class="line">    private GoodService goodService;</div><div class="line"></div><div class="line">    RateLimiter rateLimiter = RateLimiter.create(10);</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/rush&quot;)</div><div class="line">    public Object rush(HttpServletRequest request) &#123;</div><div class="line">        rateLimiter.acquire();</div><div class="line">        if (goodService.update(object) &gt; 0) &#123;</div><div class="line">            return &quot;success&quot;;</div><div class="line">        &#125;</div><div class="line">        return &quot;fail&quot;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>RateLimiter用法十分简单，它主要提供了下面方法</p>
<ul>
<li>acquire() 从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求并返回等待时间。</li>
<li>acquire(int permits) 提供一个入参指定许可数。</li>
<li>create(double permitsPerSecond) 指定每秒多少许可创建RateLimiter。</li>
<li>setRate(double permitsPerSecond) 根据许可产生速率。</li>
<li>tryAcquire()/tryAcquire(int permits) 获取许可（指定许可数),非阻塞立即返回，无法获取返回false。</li>
</ul>
<p>上面列出RateLimiter的几个重要的方法，了解了令牌桶的原理很容易理解成RateLimiter起了一个线程以一个固定的速率给一个计数器比如AtomicInteger加数字，可是真的是这样吗？我们移步代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static RateLimiter create(double permitsPerSecond) &#123;</div><div class="line">        return create(RateLimiter.SleepingTicker.SYSTEM_TICKER, permitsPerSecond);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @VisibleForTesting</div><div class="line">    static RateLimiter create(RateLimiter.SleepingTicker ticker, double permitsPerSecond) &#123;</div><div class="line">        RateLimiter rateLimiter = new RateLimiter.Bursty(ticker, 1.0D);</div><div class="line">        rateLimiter.setRate(permitsPerSecond);</div><div class="line">        return rateLimiter;</div><div class="line">    &#125;    &#125;</div></pre></td></tr></table></figure>
<p>create方法没什么好说，创建一个RateLimiter,关于这里面的SleepingTicker的作用我们稍后再说。先来看一下acquire方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public double acquire(int permits) &#123;</div><div class="line">        checkPermits(permits);  //参数校验</div><div class="line">        Object var4 = this.mutex;</div><div class="line">        long microsToWait;</div><div class="line">        synchronized(this.mutex) &#123;</div><div class="line">        //计算请求需要让线程等待多少时间</div><div class="line">            microsToWait = this.reserveNextTicket((double)permits, this.readSafeMicros());</div><div class="line">        &#125;</div><div class="line"></div><div class="line"> this.ticker.sleepMicrosUninterruptibly(microsToWait);//阻塞线程</div><div class="line">        return 1.0D * (double)microsToWait / (double)TimeUnit.SECONDS.toMicros(1L);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面计算线程的等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private long reserveNextTicket(double requiredPermits, long nowMicros) &#123;</div><div class="line">        this.resync(nowMicros);  //重新设置下一次获取时间和存储的令牌数</div><div class="line">        long microsToNextFreeTicket = this.nextFreeTicketMicros - nowMicros; //需要等待的时间</div><div class="line">        double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits);//获得请求的令牌数和存储的令牌数中的较小值</div><div class="line">        double freshPermits = requiredPermits - storedPermitsToSpend;  //如果为0 表示本次请求令牌够用,大于0表示“欠”的令牌数</div><div class="line">        long waitMicros = this.storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (long)(freshPermits * this.stableIntervalMicros);  //计算欠的令牌数需要多久产生</div><div class="line">        this.nextFreeTicketMicros += waitMicros;  //下次获取的时间</div><div class="line">    this.storedPermits -= storedPermitsToSpend; //更新令牌数</div><div class="line">        return microsToNextFreeTicket;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">private void resync(long nowMicros) &#123;</div><div class="line">        if(nowMicros &gt; this.nextFreeTicketMicros) &#123;</div><div class="line">            this.storedPermits = Math.min(this.maxPermits, this.storedPermits + (double)(nowMicros - this.nextFreeTicketMicros) / this.stableIntervalMicros);</div><div class="line">            this.nextFreeTicketMicros = nowMicros;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>resync的方法作用是设置nextFreeTicketMicros和storedPermits；nextFreeTicketMicros表示下次获取的时间，初始化为0。每调用一次acquire()，nowMicros - nextFreeTicketMicros就是上次请求到这次请求中间发生的时间。如果当前时间比上一轮设置的下次获取的时间大（因为存在提前获取的情况，比如上次直接获取了10个，那上轮设置的nextFreeTicketMicros就是上一轮的时间+5s），那就计算这个中间理论上能生成多少的令牌。比如这中间隔了1秒钟，然后stableIntervalMicros=5000（稳定生成速度的情况下）,那么，就这中间就可以生成2个令牌。再加上它原先存储的storedPermits个，如果比maxPermits大，那最大也只能存maxPermits这么多。如果比maxPermits小，那就是storedPermits=原先存的+这中间生成的数量。同时记录下下次获取的时候需要减去的时间，也就是当前时间 （nextFreeTicketMicros ）。</p>
<p>  reserveNextTicket方法计算出的时间也是请求需要等待的时间。举个例子，假设在nowMicros=3这个时间点来了一个请求，需要5个令牌，当前时间点令牌数为2，假设计算出waitMicro=3,则nexFreeTicketMicors=3,当前storedPermits=-2;该请求需要等待3s后的一致性。再假设过了1s另一请求到来需要1个令牌，则根据nexFreeTicketMicors和storedPermits继续计算waitMicro获取阻塞时间。</p>
<p>  总结起来，RateLimiter并不是真的一直往某个地方放令牌，而是在每次acquire时候根据当前令牌数和下次获取令牌算去本次请求是否能执行，如果要等需要等待多长时间，设计上非常巧妙。当第一次调用accquire()的时候，resync会被执行，然后在accquire()中将nextFreeTicketMicros设置为当前时间。但是，还可以请求的令牌数和当前存储的令牌数进行比较。如果请求的令牌数很大，则会计算出生成这些多余的令牌需要的时间，并加在nextFreeTicketMicros上，从而保证下次调用accquire()的时候，根据nextFreeTicketMicros和当时的nowMicros相减，若&gt;0，则需要等到对应的时间。也就能应对流量的突增情况了。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/14/RateLimiter/" data-id="cje5obayz0004us2m2ydcajxj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/guava/">guava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-weak-gc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/09/weak-gc/" class="article-date">
  <time datetime="2017-07-09T01:54:45.000Z" itemprop="datePublished">2017-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/09/weak-gc/">weakHashMap与GC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>WeakHashMap结构上与HashMap比较类型,内部都是通过Entry[]数组来组织数据，只不过WeakHashMap的Entry[]有些特殊，它的继承体系结构是Entry-&gt;WeakReference-&gt;Reference，这种结构保证了WeakHashMap的功能。先来看下API文档中对WeakHashMa的描述：以弱键 实现的基于哈希表的 Map。在 WeakHashMap中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除。</p>
<p>WeakHashMap的行为取决于垃圾回收器的动作。由于垃圾回收器是由jvm调度的，gc可以发生在WeakHashMap对象生命周期的任何时候，所以WeakHashMap的表现为，即使对 WeakHashMap 实例进行同步，并且没有调用任何赋值方法，在一段时间后 size 方法也可能返回较小的值，对于 isEmpty 方法，可以先返回true，然后返回true，对于给定的键，containsKey方法返回true,然后返回false，对于给定的键,get方法返回一个值,但接着返回null。总而言之就是只要在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。</p>
<h1 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h1><p>深入了解WeakHashMap之前，我们必须对java中的几种引用类型有着明确的认识：</p>
<ul>
<li><p>强引用</p>
<p>强引用是相对其他类型引用而言的。如果一个对象具有强引用，GC绝不会回收它，当内存空间不足时，JVM宁愿抛出OOM。new出来的对象是典型的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//强引用</div><div class="line">Object StrongReference = new Object();</div></pre></td></tr></table></figure>
</li>
<li><p>软引用</p>
<p>如果一个对象具有软引用，当内存空间不足，GC会回收这些对象的内存，通常可以使用软引用构建敏感数据的缓存。SoftReference中还有个timestamp字段，表示软引用还可以通过设定时间戳进行回收。软引用可以通过get方法获取强引用。声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//SoftReference</div><div class="line">SoftReference&lt;Object&gt; sr = new SoftReference&lt;~&gt;(new Object());</div><div class="line">Object StrongReference = (Object) SoftRerence.get();</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>弱引用</p>
<p>如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存，使用弱引用 构建非敏感数据的缓存。声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//WeakReference</div><div class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;~&gt;(new Object());</div></pre></td></tr></table></figure>
</li>
<li><p>虚引用</p>
<p>如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收，虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列联合使用，虚引用主要用来跟踪对象被垃圾回收的活动。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  //PhantomReference</div><div class="line">PhantomReference&lt;Object&gt; phantomReference=new PhantomReference&lt;Object&gt;(new User(),new ReferenceQueue&lt;Object&gt;());</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="WeakHashMap与GC"><a href="#WeakHashMap与GC" class="headerlink" title="WeakHashMap与GC"></a>WeakHashMap与GC</h1><p>前面我们讲到WeakHashMap中Entry[]有着Entry-&gt;WeakReference-&gt;Reference这样一个继承结构，我们先来看下Reference类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private static Lock lock = new Lock();</div><div class="line"></div><div class="line"></div><div class="line">/* List of References waiting to be enqueued.  The collector adds</div><div class="line"> * References to this list, while the Reference-handler thread removes</div><div class="line"> * them.  This list is protected by the above lock object. The</div><div class="line"> * list uses the discovered field to link its elements.</div><div class="line"> */</div><div class="line">private static Reference&lt;Object&gt; pending = null;</div><div class="line"></div><div class="line">/* High-priority thread to enqueue pending References</div><div class="line"> */</div><div class="line">private static class ReferenceHandler extends Thread &#123;</div><div class="line"></div><div class="line">    private static void ensureClassInitialized(Class&lt;?&gt; clazz) &#123;</div><div class="line">        try &#123;</div><div class="line">            Class.forName(clazz.getName(), true, clazz.getClassLoader());</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        // pre-load and initialize InterruptedException and Cleaner classes</div><div class="line">        // so that we don&apos;t get into trouble later in the run loop if there&apos;s</div><div class="line">        // memory shortage while loading/initializing them lazily.</div><div class="line">        ensureClassInitialized(InterruptedException.class);</div><div class="line">        ensureClassInitialized(Cleaner.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</div><div class="line">        super(g, name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            tryHandlePending(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是Reference类的部分代码，可以看到Reference中有一个全局的锁对象：lock;有一个静态变量pending;在静态代码块中启动一个ReferenceHandler线程，启动完成后处于wait状态，它在一个Lock同步锁模块中等待。那么WeakHashMap中key/value如何自动回收跟这些有什么关系呢。</p>
<p>我们假设JVM使用cms收集器（使用其他收集器对于弱引用的回收原理相同）。JVM 在进行CMS GC的时候，会创建一个ConcurrentMarkSweepThread（简称CMST）线程去进行GC，ConcurrentMarkSweepThread线程被创建的同时会创建一个SurrogateLockerThread（简称SLT）线程并且启动它，SLT启动之后，处于等待阶段。CMST开始GC时，会发一个消息给SLT让它去获取Java层Reference对象的全局锁：Lock。 直到CMS GC完毕之后，JVM 会将WeakHashMap中所有被回收的对象所属的WeakReference容器对象放入到Reference 的pending属性当中（每次GC完毕之后，pending属性基本上都不会为null了），然后通知SLT释放并且notify全局锁:Lock。此时激活了ReferenceHandler线程的run方法，使其脱离wait状态，开始工作了。ReferenceHandler这个线程会将pending中的所有WeakReference对象都移动到它们各自的列队当中，比如当前这个WeakReference属于某个WeakHashMap对象，那么它就会被放入相应的ReferenceQueue列队里面（该列队是链表结构）。 当我们下次从WeakHashMap对象里面get、put数据或者调用size方法的时候，WeakHashMap就会将ReferenceQueue列队中的WeakReference一一poll出来去和Entry[]数据做比较，如果发现相同的，则说明这个Entry所保存的对象已经被GC掉了，那么将Entry[]内的Entry对象剔除掉，这样就完成的key/value的自动回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * Reference queue for cleared WeakEntries</div><div class="line"> */</div><div class="line">private final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</div></pre></td></tr></table></figure>
<p>这是WeakHashMap中的ReferenceQueue定义，注释就可以知道这是用来清除WeakEntries的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Expunges stale entries from the table.</div><div class="line">    */</div><div class="line">   private void expungeStaleEntries() &#123;</div><div class="line">       for (Object x; (x = queue.poll()) != null; ) &#123;</div><div class="line">           synchronized (queue) &#123;</div><div class="line">               @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                   Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</div><div class="line">               int i = indexFor(e.hash, table.length);</div><div class="line"></div><div class="line">               Entry&lt;K,V&gt; prev = table[i];</div><div class="line">               Entry&lt;K,V&gt; p = prev;</div><div class="line">               while (p != null) &#123;</div><div class="line">                   Entry&lt;K,V&gt; next = p.next;</div><div class="line">                   if (p == e) &#123;</div><div class="line">                       if (prev == e)</div><div class="line">                           table[i] = next;</div><div class="line">                       else</div><div class="line">                           prev.next = next;</div><div class="line">                       // Must not null out e.next;</div><div class="line">                       // stale entries may be in use by a HashIterator</div><div class="line">                       e.value = null; // Help GC</div><div class="line">                       size--;</div><div class="line">                       break;</div><div class="line">                   &#125;</div><div class="line">                   prev = p;</div><div class="line">                   p = next;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>expungeStaleEntries方法描述了如何清除，getTable,size等方法会首先调用该方法。以上就是弱引用的清除过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/09/weak-gc/" data-id="cje5obazm000ius2mglzv44fr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-obejct-struct" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/04/obejct-struct/" class="article-date">
  <time datetime="2017-07-04T11:49:46.000Z" itemprop="datePublished">2017-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/04/obejct-struct/">对象内存布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  关于jvm中对象是如何分配内存的，在<a href="https://doubleclouder.github.io/2017/07/03/new-object-1/" target="_blank" rel="external">jvm源码分析之内存分配</a>中已经做过分析，现在我们就来讨论一下内存分配之后是如何布局的，简单的讲就是分配的内存区域里面到底存的是什么。</p>
<p> <img src="http://osjt45oaj.bkt.clouddn.com/struct1.png" alt=""><br> 上图引用自《java虚拟机精讲》。图中可以一目了然的看出对象的内存布局。存储对象实例信息的内存布局主要有两部分构成：对象头和实例数据以及padding区域。</p>
<ul>
<li>对象头：分成两部分Mark Word和元数据指针。Mark Word主要用于存储对象运行时的数据信息。比如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。而元数据指针则是指向方法区中目标类的类型信息，通过元数据指针可以指明当年对象是哪个类的实例。</li>
<li>实例数据：主要用于存储定义在当前对象中的各种类型的字段信息（包括派生于超类的字段）。</li>
<li>padding区：仅仅起着占位符的作用，jvm要求对象大小必须是8的倍数，若不是需要填充补齐，它不是必要存在的。</li>
</ul>
<p>当理解了Java对象在内存中如何存储之后，接下来我们看下jvm中是如何表达java类和对象实例的，底层jvm需要一套完整的内部对象表示机制，这种机制称为OOP-Klass模型，OOP(Ordinay Object Pionter)对象指针用于描述实例对象，而Klass则是用于描述对象实例的类型，对应上层java中的Class(之所以命名为Klass，是因为Class是c++中的关键字)。OOP与Klass是两个相互独立又彼此关联的模块。在JVM中对象头由OOP对象instanceOopDesc来表示，对象头中元数据指针锁指向的当前对象的目标类型是由Klass中的instanceKlass表示。栈中本地变量表中的引用变量指向堆上InstanceOopDesc对象，而instanceOopDesc对象持有只有instanceKlass的地址指针，如下图所示：</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/struct2.png" alt=""><br>下面重点分析一下mark word和实例数据部分。</p>
<h1 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h1><p>-<br>Mark Word具有非固定的数据结构，以便在极小的空间内存储尽量多的信息。JVM可以通过Java对象的元数据确定对象长度，但是对于数组不行。如果对象是一个数组，对象头必须有一块儿用于记录数组长度的数据，这么做的目的是gc扫描时会根据对象头直接确定下一个对象的地址，不需要扫描整个对象空间。对于对象头长度而言，32bit虚拟机一定是32bit+32bit，即8字节；64bit虚拟机若没有开启了压缩指针，是64bit+64bit，即16字节，若开启了压缩指针，是64bit+32bit，即12字节（不是8bit的倍数）<br>-XX:+UseCompressedOops：开启压缩指针。</p>
<h1 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h1><p>-<br>上面讲到实例数据部分存的是对象的各种类型的字段信息，包括基本类型和引用类型。我们在定义一个java类的时候不会去考虑字段的顺序，例如类A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class A&#123;</div><div class="line">   double x;</div><div class="line">   float y;</div><div class="line">   int z;</div><div class="line">   long a;</div><div class="line">   String s;</div><div class="line">   ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是jvm在创建对象的时候会按照一定的顺序去排列这些字段，顺序如下：</p>
<ol>
<li>double/long       8byte</li>
<li>float/int         4byte</li>
<li>short/char        2byte</li>
<li>byte/boolean      1byte</li>
<li>oop        4/8byte</li>
</ol>
<p>jvm默认以这种顺序去排列字段，这样做的原因是cpu读取内存时是按寄存器的大小单位（64位机器为64bit）载入的，如果载入的数据横跨两个64bit,要操作该数据的话必须两次读取加上组合移位，会产生效率问题，甚至会引发异常，所以必须要求数据对齐,同时也可以节省内存。<br>这种顺序也是可以更改的。通过指定jvm参数-XX:fIeldsAllocationStyle=mode，缺省状态下，jvm默认mode=1,mode还可以为0和2。为0时oop位于前面；mode=2时会将当前类和超类的oop字段放在一起，mode为0或1时会将派生类和超类的基本按照上述规则排在一起，oop类型位置不变，mode=2则也会将oop类型放在一起。按照jvm代码的注释可能更清晰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mode=0,Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields</div><div class="line">mode=1:Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields</div><div class="line">mode=2:Fields allocation: oops fields in super and sub classes are together.</div></pre></td></tr></table></figure>
<p>相当mode=0和1，mode=2的优势是可以减少gc时创建的OopMapBlock对象的数量。OopMapBlock结构如下：<br><img src="http://osjt45oaj.bkt.clouddn.com/struct3.png" alt=""><br>我们都知道gc时需要从gc root对象开始定位所有的存活的对象，那么就需要根据引用链记录对象指针，而OopMapBlock对象就是用来存放对象指针的，它有两个字段offset(偏移量)和对象个数(count),如果oop是连续的，对于同一个对象只需要一个OopMapBlock对象记录oop开始位置的便宜量和oop的个数就ok,否则需要两个oopMapBlock。另外一个好处是连续的对象区域使得cache line的使用效率更高. 试想如果父对象和子对象的对象引用区域不连续, 而中间插入了原始类型字段的话, 那么在做GC对象扫描时, 很可能需要跨cache line读取才能完成扫描.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/04/obejct-struct/" data-id="cje5obazk000gus2mbrd6yizn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-new-object-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/03/new-object-1/" class="article-date">
  <time datetime="2017-07-03T11:57:46.000Z" itemprop="datePublished">2017-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/new-object-1/">jvm源码分析之内存分配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="new-Object"><a href="#new-Object" class="headerlink" title="new Object"></a>new Object</h1><p>  java程序猿找不到对象怎么办，最简单的办法:new一个。（扎心了，对象还是要自己找。。）。new关键字大家都很熟悉，我们使用new来实例化任何我们需要的对象。Object object = new Object()一行代码对象创建完成，但是大家是否有了解过这行代码背后都做了些什么？其实底层jvm做了一系列非常复杂的工作，现在我们就来扒一扒。</p>
<p>  创建一个java对象需要三步：声明引用变量、实例化、初始化对象实例。实例化是真正创建一个java对象，分配内存并返回指向改内存的引用。初始化是指调用构造方法，对类的实例数据赋初值。对于Object object = new Object()可以分成两个部分，”Object obj”这部分的语义作用于Java栈中，会在栈帧中的本地变量表中创建一个引用类型的数据obj,而”new Object()”这部分的语义将会作用于java堆中，形成一块存储Object类型的所有实例数据值的内存区域（当然严格的来讲，对象也是可以在栈上分配内存的，jvm中可以借助对象的逃逸分析来决定一些小对象是否在可以进行栈上分配，这样做的目的是为了降低GC回收频率以及提升GC回收效率，但这毕竟只是一种jvm调优的辅助手段，绝大多数对象实例只能在java堆区分配存储）。下面我们就通过源码看一下对象的内存到底是如何分配的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class AAA&#123;</div><div class="line">  public static void main(string[] args)&#123;</div><div class="line">    Object = new Object()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 利用javap命令反编译上面的代码可以得到：</p>
<p> <img src="http://osjt45oaj.bkt.clouddn.com/image.jpg" alt="photo"></p>
<p> 可以看到java中new关键字对应底层jvm中的new指令，下面我们就来看一下jvm中new指令的实现：</p>
<p> <img src="http://osjt45oaj.bkt.clouddn.com/image2.png" alt="photo"></p>
<p>首先会尝试去常量池的对应位置找指定类（这里是Object类）的instanceKlass对象（可了解jvm中定义类与对象关系的oop-klass模型）。如果找到说明类已经被加载，否则触发类的初始化过程，这里不再详解，我们直接看对象内存是如何分配的，在allocate_instance方法中。</p>
<p>在讲内存分配过程之前，我们先来了解下内存的几种方式，如果不考虑jvm借助逃逸分析来进行栈上分配，绝大多数对象都是在堆上进行分配的，这点毫无疑问。内存分配的方式如下：</p>
<ul>
<li>指针碰撞：如果内存是规整有序的，分配对象内存时只需要移动指针来划分内存区域。</li>
<li>空闲列表：如果内存不是规整的，则记录下空闲内存的地址，申请内存时从列表上获取内存地址。</li>
<li>快速分配：上述分配方式在多线程环境下，必须让线程分配内存保持同步（通过先cas,后加锁的方式），这样导致内存分配的效率很低，为了解决线程同步的问题，jvm引入了tlab这种快速分配的方式。</li>
</ul>
<p>先来简单介绍下tlab(threadLocalAllocationBuffer)。tlab是线程在eden上划分的一块私有区域，通过start、end两个指针卡出一块内存空间，这块空间只能由当前线程在上面进行对象内存分配，由一个top指针在这块卡出的区域移动，类似于指针碰撞。tlab并不是线程私有内存，它是卡出一块空间只让当前线程进行内存分配，这块空间是eden的空间，上面分配的对象还是线程共享的。了解了这样一个概念，我们就继续看下内存的代码，入口是上面提到的allocate_instance.</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new1.png" alt="allocate"></p>
<p>方法中会先判断当前类是否实现了finalize方法，如果有则会创建finalizer对象。我们直接跟内存分配的代码：</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new2.png" alt=""></p>
<p>继续看Common_mem_allocate_init方法最终会调到CollectedHeap::common_mem_allocate_noinit方法</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new3.png" alt=""></p>
<p>这里会看到如果使用tlab，会尝试去tlab上分配，jvm默认开启tlab,jvm中线程run方法会首先去初始化一个tlab。如果不使用tlab，则在直接在堆上分配，这个后面再说，我们先看下tlab上分配。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new4.png" alt=""></p>
<p>这里会首先尝试在tlab上分配，如果分配失败则进行慢速分配。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new5.png" alt=""></p>
<p>tlab有个最大可浪费空间的字段，如果当前tlab剩余空间大于要分配的空间，则直接分配，否则会看剩余空间是否大于可浪费空间，若是则直接在eden上分配对象空间，若否则重新丢弃当前tlab，重新在堆上开辟一块tlab,这就是上面提到的慢速分配过程。代码如下：</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new6.png" alt=""></p>
<p>本质上在堆上分配对象空间和分配tlab是一样的，这块内存都是临时的下面看一下堆是如何分配tlab的。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new7.png" alt=""></p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new8.png" alt=""><br>首先会确保当前JVM没有进行gc,如果正在gc则不进行分配。首先通过自旋+cas这种活锁的方式进行原子分配，上面代码中的par_allocate会调用jvm的cas指令如下：<br><img src="http://osjt45oaj.bkt.clouddn.com/new9.png" alt=""></p>
<p>如果无锁的方式分配失败，则继续执行mem_allocate_work下面的代码,无锁分配失败后则以加锁的方式继续尝试分配</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/new10.png" alt=""><br><img src="http://osjt45oaj.bkt.clouddn.com/new11.png" alt=""></p>
<p>first_only代表是否只在新生代分配，根据上面的代码可以看出大的对象这个值为false，在attempt_allocation方法中，会遍历所有的内存代尝试分配内存，如果first_only为true的话则只在新生代进行分配，如果分配失败直接返回。<br>继续看mem_allocate_work下面的代码：<br>如果上面分配内存仍然失败，则继续执行。<br><img src="http://osjt45oaj.bkt.clouddn.com/new12.png" alt=""><br>1、gc_locker::is_active_and_needs_gc()为真时，表示当前其它线程已经触发了gc；<br>2、如果is_tlab为真，表示当前线程正在为局部分配缓冲区申请内存；<br>3、如果!gch-&gt;is_maximal_no_gc()为真，表示新生代或老年代可以进行内存扩展，扩展完成后，再次尝试从各代中进行分配expand_heap_and_allocate方法。<br>4.如果拓展后分配仍然不成功，则继续往下执行<br><img src="http://osjt45oaj.bkt.clouddn.com/new13.png" alt=""><br>如果当前线程没有位于jni的临界区，将释放Java堆的互斥锁，以使得请求gc的线程可以进行gc操作，等所有本地线程退出临界区和gc完成后，将继续循环尝试分配内存。<br>如果还是分配不成功，则执行GC操作.<br><img src="http://osjt45oaj.bkt.clouddn.com/new14.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述就是jvm中关于对象分配内存的整个流程，jvm会优先以快速分配的方式在tlab上进行，如果分配失败进行堆上分配或者执行tlab的refill过程，期间还有gc的参与，最终是为了给对象在堆上分配一块内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/03/new-object-1/" data-id="cje5obazi000fus2m4c62peyv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JDK-Dynamic-Proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/12/JDK-Dynamic-Proxy/" class="article-date">
  <time datetime="2017-04-12T11:53:23.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/JDK-Dynamic-Proxy/">JDK动态代理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说到动态代理，我们先来说说代理模式。代理模式是Java中一种常见的也是非常重要的设计模式，先来看下定义：当一个对象不适合或者无法直接访问另一对象时，通过一个代理来控制对另一对象的访问，这个代理对象就起到了一个中介的作用。代理模式的主要特征是代理类和委托类实现同一接口。下面就是代理模式最基本的结构图。<br><img src="http://osjt45oaj.bkt.clouddn.com/proxy1.png" alt=""><br>根据这个定义，我们先写一个简单的代理模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public interface Service &#123;</div><div class="line">    void doService();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ProxyDemo &#123;</div><div class="line"></div><div class="line">    class ServiceImpl implements Service&#123;</div><div class="line">        @Override</div><div class="line">        public void doService() &#123;</div><div class="line">            System.out.println(&quot;do some service&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class Proxy implements Service&#123;</div><div class="line">        private Service service;</div><div class="line"></div><div class="line">        public Proxy(Service service)&#123;</div><div class="line">            this.service = service;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void doService() &#123;</div><div class="line">            System.out.println(&quot;do something before&quot;);</div><div class="line">            service.doService();</div><div class="line">            System.out.println(&quot;do something after&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Service service = new ProxyDemo().new ServiceImpl();</div><div class="line">        Service proxy = new ProxyDemo().new Proxy(service);</div><div class="line">        proxy.doService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是代理模式的一种基本实现，我们称之静态代理。它可以在不修改目标对象的前提下，对目标功能进行拓展。所以缺<br>点也是显而易见的。因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，而且,一旦接口增加方法,目标对象与代理对象都要维护。动态代理就解决了这些问题。</p>
<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>动态代理有两种，JDK动态代理和cglib动态代理，本文我先来深入探讨一下JDK动态代理。JDK动态代理需要我们实现<br>InvocationHandler接口，在invoke方法中对目标类的目标方法进行增强（即定义横切逻辑），还是先上代码看下如何使用。</p>
<p><img src="http://osjt45oaj.bkt.clouddn.com/proxy2.png" alt=""><br>这就是jdk动态代理的基本用法，实际这就是一个aop了，spring aop也是使用Proxy和InvocationHandler这两个<br>类来进行方法增强的。通过这种方式我们就可以动态的代理目标对象，可是它是怎么达到效果的呢？知其然，知其所以然。下面就跟下这两个类的源码。<br><img src="http://osjt45oaj.bkt.clouddn.com/proxy3.png" alt=""><br>上面是Proxy#newProxyInstance方法。我们先看下729行，这里调用目标类的构造方法，然后739行，实例化目标类<br>并将对象返回给上面的MyInvocationHandler。我们再跟进上面的getproxyClass方法看下。<br><img src="http://osjt45oaj.bkt.clouddn.com/proxy4.png" alt=""><br>进入proxyClassCache.get这里先看目标接口的实例是否有缓存，有就直接返回。没有就通过ProxyclassFactory<br>这个工厂类创建并加入缓存。最近通过ProxyclassFactory的apply方法创建实例。<br><img src="http://osjt45oaj.bkt.clouddn.com/proxy5.png" alt=""><br>中间一些校验的逻辑跳过<br><img src="http://osjt45oaj.bkt.clouddn.com/proxy6.png" alt=""><br>上面的639行：ProxyGenerator#GenerateProxyClass方法才是生成代理类的关键所在，它其实是动态生成字节码并<br>保存到硬盘。到这里我们也就了解了jdk是怎样动态的生成的代理类了，可是代理类是怎么样调到我们上面的InvocationH<br>andler的invoke方法的呢？实际上这个生成代理类会传入一个InvocationHandler对象，代理类在覆盖接口的目标方<br>法中会调用invoke方法。JDK动态代理大致上就是这样一个过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/12/JDK-Dynamic-Proxy/" data-id="cje5obayo0000us2mhpfogl3z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/10/singleton/" class="article-date">
  <time datetime="2017-04-10T02:14:19.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/singleton/">深入单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如何确保一个java类只被实例化一次？很显然，答案是单例模式。单例模式是一种常见而且非常有用的设计模式，我们到处能看见单例模式的身影，比如创建各种连接池、线程池、日志对象等。单例类通过自行实例化并且在系统中有实例请求时提供这个实例，从而确保该类只被实例化一次。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p><img src="http://osjt45oaj.bkt.clouddn.com/singleton1.png" alt=""><br>懒汉式实际上是一种懒加载，但为了在多线程环境下不破坏单例，需要在获取实例时增加双重检查或静态内部类的方式确保线程安全。<br><img src="http://osjt45oaj.bkt.clouddn.com/singleton2.png" alt=""><br>通过双重检测可以确保singleton只被实例化一次，但这里其实还是有问题，因为对象初始化和为对象引用赋值存在指令重排序，线程判断singleton不为null时返回的可能是一个未初始化的对象，可以用volatile关键字解决，这里不做赘述。我们还可以通过静态内部类的方式达到线程安全的目的。<br><img src="http://osjt45oaj.bkt.clouddn.com/singleton3.png" alt=""><br>通过静态内部类的方式获取Singleton的实例是线程安全的，因为jvm保证类的加载和初始化过程是线程安全的，所以此种方式创建单例既实现线程安全，又避免同步带来的性能英雄，要优于双重检查的方式。<br>那么问题来了，上面线程安全的单例是否不论什么情况下都只有一个实例？答案是否定的。我们可以通过反射和反序列化来破坏单例。<br><img src="http://osjt45oaj.bkt.clouddn.com/singleton4.png" alt=""><br>上面是通过反射的方式强行调用构造方法，显然输出结果为false。当单例类实现了Serializable接口，即该类对象可序列化时，可以通过序列化和反序列化过程自行获取实例。序列化与反序列可以实现对象的深拷贝。<br><img src="http://osjt45oaj.bkt.clouddn.com/singleton5.png" alt=""><br>为了防止这种暴力的破坏单例，可以对上面的单例类稍加改造。<br><img src="http://osjt45oaj.bkt.clouddn.com/singleton6.png" alt=""><br> 到此为止，我们就创建了一个严格意义的单例，实际上枚举类内部实现与此类似，所以枚举是实现单例最好的方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/10/singleton/" data-id="cje5obazr000mus2m43tzhrp6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/guava/">guava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/guava/" style="font-size: 15px;">guava</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/19/kafka-one/">kafka学习笔记（一）kafka简介</a>
          </li>
        
          <li>
            <a href="/2017/09/24/dynamic-proxy/">ASM初探</a>
          </li>
        
          <li>
            <a href="/2017/08/27/mybatis-cache/">mybatis缓存体系</a>
          </li>
        
          <li>
            <a href="/2017/07/23/redis-list/">redis消息队列实现</a>
          </li>
        
          <li>
            <a href="/2017/07/14/RateLimiter/">接口限流之RateLimiter</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zhusheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>